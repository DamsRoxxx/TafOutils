/* (c) Copyright 2003-2015, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)pres_writerHistoryDriver.h    generated by: makeheader    Fri Feb 16 13:51:43 2018
 *
 *		built from:	writerHistoryDriver.ifc
 */

#ifndef pres_writerHistoryDriver_h
#define pres_writerHistoryDriver_h


  #ifndef osapi_type_h
    #include "osapi/osapi_type.h"
  #endif
  #ifndef reda_fastBuffer_h
    #include "reda/reda_fastBuffer.h"
  #endif
  #ifndef mig_generator_h
    #include "mig/mig_generator.h"
  #endif
  #ifndef pres_dll_h
    #include "pres/pres_dll.h"
  #endif
  #ifndef pres_participant_h
    #include "pres/pres_typePlugin.h"
  #endif
  #ifndef pres_participant_h
    #include "pres/pres_participant.h"
  #endif
  #ifndef pres_common_h
    #include "pres/pres_common.h"
  #endif
  #ifndef writer_history_interface_h
    #include "writer_history/writer_history_interface.h"
  #endif
#ifdef __cplusplus
    extern "C" {
#endif


#define PRES_WRITER_ALLOW_OUT_OF_ORDER_WRITE_PROPERTY "dds.data_writer.history.allow_out_of_order_write"
#define PRES_WRITER_DISABLE_INLINE_KEYHASH_IN_DISPOSE_PROPERTY "dds.data_writer.protocol.disable_inline_keyhash_in_dispose"
#define PRES_WRITER_DISABLE_SERIALIZE_KEY_IN_DOSPOSE_PROPERTY "dds.data_writer.protocol.disable_serialize_key_in_dispose"
#define PRES_WRITER_SEND_MULTICAST_PERIODIC_HEARTBEATS_PROPERTY "dds.data_writer.protocol.send_multicast_periodic_heartbeats"
#define PRES_WRITER_MULTICAST_REPAIR_THRESHOLD_PROPERTY "dds.data_writer.protocol.multicast_repair_threshold"

/*** begin turbo mode properties ***/
/* document this property */
#define PRES_WRITER_TURBO_MODE_PROPERTY "dds.data_writer.enable_turbo_mode"

/* don't document these properties */
#define PRES_WRITER_TURBO_MODE_MAX_DATA_BYTES_PROPERTY "dds.data_writer.turbo_mode.max_data_bytes"
#define PRES_WRITER_TURBO_MODE_MAX_META_DATA_BYTES_PROPERTY "dds.data_writer.turbo_mode.max_meta_data_bytes"
#define PRES_WRITER_TURBO_MODE_MAX_FLUSH_DELAY_MICROSEC_PROPERTY "dds.data_writer.turbo_mode.max_flush_delay_microsec"
#define PRES_WRITER_TURBO_MODE_SAMPLES_PER_REEVALUATION_PROPERTY "dds.data_writer.turbo_mode.samples_per_reevaluation"
#define PRES_WRITER_TURBO_MODE_FREQUENCY_MIN_PROPERTY "dds.data_writer.turbo_mode.frequency_min"
#define PRES_WRITER_TURBO_MODE_FREQUENCY_MAX_PROPERTY "dds.data_writer.turbo_mode.frequency_max"
#define PRES_WRITER_TURBO_MODE_MAX_DATA_BYTES_DEFAULT 32725
#define PRES_WRITER_TURBO_MODE_MAX_META_DATA_BYTES_DEFAULT 32725
#define PRES_WRITER_TURBO_MODE_MAX_FLUSH_DELAY_MICROSEC_DEFAULT 1000
#define PRES_WRITER_TURBO_MODE_SAMPLES_PER_REEVALUATION_DEFAULT 100
#define PRES_WRITER_TURBO_MODE_FREQUENCY_MIN_DEFAULT 10
#define PRES_WRITER_TURBO_MODE_FREQUENCY_MAX_DEFAULT 10000
/*** end turbo mode properties ***/

#define PRES_INTER_PARTICIPANT_DISABLE_INLINE_KEYHASH_PROPERTY "dds.participant.inter_participant_data_writer.protocol.disable_inline_keyhash"
#define PRES_INTER_PARTICIPANT_DISABLE_INLINE_KEYHASH_IN_DISPOSE_PROPERTY "dds.participant.inter_participant_data_writer.protocol.disable_inline_keyhash_in_dispose"
#define PRES_INTER_PARTICIPANT_DISABLE_SERIALIZE_KEY_IN_DOSPOSE_PROPERTY "dds.participant.inter_participant_data_writer.protocol.disable_serialize_key_in_dispose"

#define PRES_PARTICIPANT_DISCOVERY_DISABLE_INLINE_KEYHASH_PROPERTY "dds.participant.discovery_data_writer.protocol.disable_inline_keyhash"
#define PRES_PARTICIPANT_DISCOVERY_DISABLE_INLINE_KEYHASH_IN_DISPOSE_PROPERTY "dds.participant.discovery_data_writer.protocol.disable_inline_keyhash_in_dispose"
#define PRES_PARTICIPANT_DISCOVERY_DISABLE_SERIALIZE_KEY_IN_DOSPOSE_PROPERTY "dds.participant.discovery_data_writer.protocol.disable_serialize_key_in_dispose"

#define PRES_WRITER_HISTORY_LOCAL_DURABILITY_PROPERTY "dds.data_writer.history.local_durability"

#define PRES_WRITER_HISTORY_KEY_MATERIAL_KEY_PROPERTY "dds.data_writer.history.key_material_key"

#define PRES_WRITER_HISTORY_ENDIANNESS_PROPERTY "dds.data_writer.history.endianness"

#define PRES_WRITER_KEEP_READER_APPACK_STATE_PROPERTY "dds.data_writer.protocol.keep_reader_appack_state"

/* these two sentinels are used by the writerHistoryDriver. We decide to
   set them in presentation to avoid having this concept in writer_history
   and having to duplicate code for odbc and memory implementations */

/* this sentinel is use by the writerHistoryDriver to calculate the
   max non reclaimable count (protocol) across all the sessions */
#define PRES_WRITER_HISTORY_MAX_ACROSS_SESSIONS_ID -2

/* this sentinel is use by the writerHistoryDriver to calculate the
   sum of all the non reclaimable count (protocol) in all the sessions */
#define PRES_WRITER_HISTORY_SUM_ACROSS_SESSIONS_ID -3

struct PRESWriterHistoryDriverUnblockListener;

struct PRESWriterHistoryDriverUnblockListenerStorage {
    void *field[4];
};

struct REDAWorker;

typedef void (*PRESWriterHistoryDriverOnUnblockCallback)(
    const struct PRESWriterHistoryDriverUnblockListener *listener,
    const struct PRESWriterHistoryDriverUnblockListenerStorage *storage,
    struct REDAWorker *worker);

struct PRESWriterHistoryDriverUnblockListener {
    PRESWriterHistoryDriverOnUnblockCallback onUnblock;
};

struct PRESWriterHistoryDriver;

typedef enum {
    PRES_WRITER_HISTORY_DRIVER_DATA_SAMPLE_KIND = 0x00,
    PRES_WRITER_HISTORY_DRIVER_UNREGISTER_SAMPLE_KIND = 0x01,
    PRES_WRITER_HISTORY_DRIVER_DISPOSE_SAMPLE_KIND = 0x02,
    PRES_WRITER_HISTORY_DRIVER_UNREGISTER_DISPOSE_SAMPLE_KIND = 0x03,
    PRES_WRITER_HISTORY_DRIVER_END_COHERENCY_SAMPLE_KIND = 0x04
} PRESWriterHistoryDriverSampleKind;

struct PRESWriterHistoryDriverTurboModeProperty {
    RTIBool enable;
    /* Frequency such that if currentFrequency is at most this value, then the
       new currentMaxWritePerBatchBytes is 1. */
    int minFrequency;
    /* Frequency such that if currentFrequency is at least this value, then the
       new currentMaxWritePerBatchBytes is maxMaxWritePerBatchBytes. */
    int maxFrequency;
    /* Maximum limit for currentMaxWritePerBatchBytes. */
    int maxMaxWritePerBatchBytes;
    /* Total number of writes within a reevaluation period. */
    int samplesPerReevaluation;
};


  #define PRES_WRITER_HISTORY_DRIVER_TURBO_MODE_PROPERTY_DEFAULT { \
   RTI_FALSE, /* enable */ \
   PRES_WRITER_TURBO_MODE_FREQUENCY_MIN_DEFAULT, /* minFrequency */ \
   PRES_WRITER_TURBO_MODE_FREQUENCY_MAX_DEFAULT, /* maxFrequency */ \
   PRES_WRITER_TURBO_MODE_MAX_DATA_BYTES_DEFAULT, /* maxMaxWritePerBatchBytes */ \
   PRES_WRITER_TURBO_MODE_SAMPLES_PER_REEVALUATION_DEFAULT /* samplesPerReevaluation */ \
  }

struct PRESWriterHistoryDriverProperty {
    /*e Control growth in number of entries. */
    struct REDAFastBufferPoolGrowthProperty entryCount;

    /*e The maximum allowable number of entries per instance. */
    int maximalEntryPerInstanceCount;

    /*e Number of hash buckets for instances.
    */
    int instanceHashBuckets;

    /*e Number of instances to allocate initially. */
    struct REDAFastBufferPoolGrowthProperty instanceCount;

	/*e Number of durableSubscriptions to allocate initially. */
    struct REDAFastBufferPoolGrowthProperty durableSubscriptionCount;

    /*e Control growth in number of concurrent (blocking) write. */
    struct REDAFastBufferPoolGrowthProperty outstandingWriteCount;

    /*e Denotes whether the disposal of an instance should also automatically
      unregister the instance.  This is generally used when it is known that
      instances are only ever written by a single writer. */
    RTIBool autoUnregister;

    /*e Whether the owner/writer of the wh is publishing asynchronously.
        Under best effort, asynchronous writer needs samples to remain in queue
        until fully sent. */
    RTIBool asynchronousPublishing;

    /*e The reliability QoS. */
    struct PRESReliabilityQosPolicy reliabilityQos;
    /*e The deadline QoS.
      A period set to RTI_NTP_TIME_MAX is interpreted as infinite.  In addition,
      the period may not exceed PRES_DEADLINE_QOS_POLICY_DEADLINE_PERIOD_MAX. */
    struct PRESDeadlineQosPolicy deadlineQos;
    /*e The history QoS. */
    struct PRESHistoryQosPolicy historyQos;
    /*e The durability QoS. */
    struct PRESDurabilityQosPolicy durabilityQos;
    /*e The destinationOrder Qos */
    struct PRESDestinationOrderQosPolicy destinationOrderQos;
    /* e The service QoS policy
    */
    struct PRESServiceQosPolicy serviceQos;
    /*e The lifespan QoS.
      A lifespan duration set to RTI_NTP_TIME_MAX is interpreted as
      infinite. In addition, the duration may not exceed
      PRES_LIFESPAN_QOS_POLICY_LIFESPAN_DURATION_MAX. */
    struct PRESLifespanQosPolicy lifespanQos;
    struct PRESTypeSupportQosPolicy typeSupport;
    /*e If there are not enough resource limits to satisfy the history depth
      when the history kind is KEEP_LAST but there are at least enough to
      satisfy a history depth of 1, thie value denotes whether to sacrifice
      reliability by dropping all but the last unacked sample of an instance
      if necessary in order to avoid blocking. */
    RTIBool sacrificeReliability;
    /*e Maximum size of the serialized user data.
    */
    int userDataBufferMaxSizeSerialized;
    /*e Maximum size of the serialized key data.
    */
    int keyDataBufferMaxSizeSerialized;
    /*e Indicates whether or not keyhash must be sent on the wire for data samples
    */
    RTIBool disableInlineKeyhash;
    /*e Indicates whether or not keyhash must be sent on the wire for dispose samples
        The value of this property cannot be configured using the public API.

        However, we introduced an internal property (not documented) that allows to
        disable the inline keyhash for dispose samples.

        In the future we may want to unify the behavior of dispose and data samples
        in terms of sending the keyhash info.

        We did not do this at this point because we would generate incompatibilities
        with 4.4c and below where keyhash in dispose is required.
    */
    RTIBool disableInlineKeyhashInDispose;
    /*e Indicates whether or not the serialized key must attached to dispose
        samples. This value and disableInlineKeyhashInDispose cannot
        be both false */
    RTIBool disableSerializeKeyInDispose;

    /*e Indicates whether or not a new instance handle is automatically registered
     *  when it is written if it was not registered or was unregistered before
     */
    RTIBool autoregisterInstances;

    /*-------------------------------------------------------------------------*/
    /* Session support */
    /*-------------------------------------------------------------------------*/

    /* Number of sessions for live data (does not include topic-query session) */
    RTI_UINT32 numberOfSessions;

    RTIBool enableTopicQueries;

    /*e The locator Filter policies.
       (This is just a pointer to writer's copy, which is immutable),
       and there is no point attempting a deep copy, since the
       locator filter policies themselves are pointers to a compiled
       SQL program, so if the master goes away it wont' work anyway). */
    struct PRESSequenceLocatorFilterPolicy *locatorFilterPolicies;

    /* Pool buffer threshold for CDR encapsulation
       Set with the property NDDS_DWHISTORY_MEMORYMANAGER_FASTPOOL_POOLBUFFERMAXSIZE */
    int cdrPoolBufferThreshold;

    /*
     * Pool buffer thresholds for all the encapsulations.
     */
    int encapsulationPoolBufferThresholds[NETIO_LOCATOR_ENCAPSULATION_COUNT_MAX];

    /*-------------------------------------------------------------------------*/
    /* Batch support */
    /*-------------------------------------------------------------------------*/

    RTIBool batchEnabled;
    RTIBool batchProtectedWrite;
    RTIBool batchEnforceMaxDataBytes;
    RTI_INT32 batchMaxSize;
    RTI_INT32 batchMaxMetaSize;
    RTI_INT32 batchMaxSampleCount;
    RTI_INT32 initialBatches;
    RTI_INT32 maxBatches;
    struct RTINtpTime batchSourceTimestampResolution;

    /*-------------------------------------------------------------------------*/
    /* Disabled ACK support */
    /*-------------------------------------------------------------------------*/

    struct RTINtpTime minAckDelay;
    struct RTINtpTime maxAckDelay;
    RTIBool enableAdaptiveAckDelay;
    struct RTINtpTime ackDelayMinSeparation;

    RTI_INT32 cookieMaxBufferSize;

    RTI_INT32 sendWindowSize;
    PRESInstanceReplacementPolicy instanceReplacementPolicy;
    RTIBool replaceEmptyInstances;

    /*-------------------------------------------------------------------------*/
    /* Collaborative DataWriters support */
    /*-------------------------------------------------------------------------*/

    RTIBool enableVirtualHB;
    struct REDASequenceNumber initialVirtualSequenceNumber;

    int initialVirtualWriters;
    int maxVirtualWriters;

    /*-------------------------------------------------------------------------*/
    /* Group Ordered Access support */
    /*-------------------------------------------------------------------------*/

    /* The access_scope is cached in the Writer History Driver to avoid having
       to take an EA when writing a batch. accessScope is checked to see if we
       need to send virtual GUID and virtual sequence number with a batch. */
    struct PRESPresentationQosPolicy presentationQos;

    RTIBool allowOutOfOrderWrite;

    /*-------------------------------------------------------------------------*/
    /* Purge instance on unregistration (see RFEs #439 and #358) */
    /*-------------------------------------------------------------------------*/

    struct RTINtpTime autopurgeUnregisteredInstancesDelay;

    struct RTINtpTime autopurgeDisposedInstancesDelay;


    RTI_UINT32 maxRemoteReaderFilters;

    /* Whether or not to store filtering status in the queue.
     * NOTE: This property cannot be configured by any API.
     */
    RTIBool storeFilterStatus;

    /*-------------------------------------------------------------------------*/
    /* Optimized Writer Side Filtering Support */
    /*-------------------------------------------------------------------------*/

    /* Flag indicating if the optimization enabled */
    RTIBool useKeyOnlyReaderOptimization;
    /* Fast Buffer Pool property for creating the key only filtered reader pool*/
    struct REDAFastBufferPoolProperty  filteredReaderPoolP;

    /*-------------------------------------------------------------------------*/
    /* AppAck support */
    /*-------------------------------------------------------------------------*/

    int maxRemoteReaders;
    int maxAppAckRemoteReaders;
    RTIBool keepReaderAckState;
    RTIBool propagateAppAckWithNoResponse;

    /*-------------------------------------------------------------------------*/
    /* Req Subscription support                                                */
    /*-------------------------------------------------------------------------*/

    RTIBool supportsRequiredSubscriptions;

    /*-------------------------------------------------------------------------*/
    /* Turbo Mode support                                                      */
    /*-------------------------------------------------------------------------*/

    struct PRESWriterHistoryDriverTurboModeProperty turboMode;

    /*-------------------------------------------------------------------------*/
    /* Serialization-related properties                                        */
    /*-------------------------------------------------------------------------*/
    /* CORE-7296 */
    RTIBool use42eAlignment;
    /* CORE-6269: C++ type may require filtering on serialized */
    RTIBool typeRequiresFilterOnSerialized;

    /*-------------------------------------------------------------------------*/
    /* Security support                                                        */
    /*-------------------------------------------------------------------------*/

    char *keyMaterialKey;

    /* Indicates if the keyhash generation is secure. This is set to TRUE
     * when data protection kind is set to ENCRYPTION or the test property
     * dds.type_plugin.force_md5_keyhash is set to true
     */
    RTIBool forceMD5KeyHash;

    /* By default, a DataWriter uses the native endianness to encode the data
     * However this behavior can be overwritten by setting this value to
     * something different than MIG_GENERATOR_ENDIAN_UNKNOWN
     *
     * This is usually done for testing purposes using the property:
     * "dds.data_writer.history.endianness"
     */
    MIGGeneratorEndian endianness;

    /* SEC-618: When set to TRUE the DataWriter will compute the signature
     * of the samples and it will add it as an inline QoS */
    RTIBool generateSampleSignature;

    /* SEC-618: randomly generated number that identifies a participant's
     * session.
     */
    int nonce;
    
    /* Topic name of the writer queue CORE-7751 */
    char *topicName;

    /* Topic name of the writer queue CORE-7751 */
    char *typeName;
};


  #define PRES_WRITER_HISTORY_DRIVER_PROPERTY_DEFAULT { \
    /* entryCount */                           \
    {32, REDA_FAST_BUFFER_POOL_UNLIMITED, REDA_FAST_BUFFER_POOL_UNLIMITED}, \
    -1,  /* maximalEntryPerInstanceCount: unlimited */\
    1, /* instanceHashBuckets */ \
    /* instanceCount */                        \
    {8, REDA_FAST_BUFFER_POOL_UNLIMITED, REDA_FAST_BUFFER_POOL_UNLIMITED}, \
	/* durableSubscriptionCount */                        \
    {8, REDA_FAST_BUFFER_POOL_UNLIMITED, REDA_FAST_BUFFER_POOL_UNLIMITED}, \
    {1, 4, REDA_FAST_BUFFER_POOL_UNLIMITED}, /* outstandingWriteCount */ \
    RTI_FALSE, /* autoUnregister */                   \
    RTI_FALSE, /* asynchronousPublishing */ \
    PRES_BEST_EFFORT_RELIABILITY_QOS_POLICY_DEFAULT,               \
    {RTI_NTP_TIME_MAX},                               \
    {PRES_KEEP_LAST_HISTORY_QOS,PRES_NONE_REFILTER_QOS,1},\
    PRES_DURABILITY_QOS_POLICY_DEFAULT,                   \
    {PRES_BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS,    \
    PRES_INSTANCE_SCOPE_DESTINATIONORDER_QOS, {0, 429496729}}, /* 100ms */\
    {PRES_NO_SERVICE_QOS},                            \
    {RTI_NTP_TIME_MAX},                               \
    PRES_TYPE_SUPPORT_QOS_POLICY_DEFAULT, /* typeSupport */\
    RTI_TRUE,-1,-1,                  \
    RTI_FALSE, /* disableInlineKeyhash */ \
    RTI_FALSE, /* disableInlineKeyhashInDispose */ \
    RTI_FALSE, /* disableSerializeKeyInDispose */ \
    RTI_FALSE, /* autoregisterInstances */ \
    1, /* numberOfSessions */ \
    RTI_FALSE, /* enableTopicQueries */ \
    NULL, /* locatorFilterPolicies pointer */ \
    PRES_LENGTH_UNLIMITED, /* cdrPoolBufferThreshold */ \
    {PRES_LENGTH_UNLIMITED, PRES_LENGTH_UNLIMITED, \
     PRES_LENGTH_UNLIMITED, PRES_LENGTH_UNLIMITED, \
     PRES_LENGTH_UNLIMITED, PRES_LENGTH_UNLIMITED, \
     PRES_LENGTH_UNLIMITED, PRES_LENGTH_UNLIMITED}, /* encapsulationPoolBufferThresholds */ \
    RTI_FALSE, /* batchEnabled */ \
    RTI_FALSE, /* batchProptedtedWrite */ \
    RTI_FALSE, /* enforceMaxDataBytes */ \
    PRES_LENGTH_UNLIMITED, /* batchMaxSize */ \
    PRES_LENGTH_UNLIMITED, /* batchMaxMetaSize */ \
    PRES_LENGTH_UNLIMITED, /* batchMaxSampleCount */ \
    1, /* initialBatches */ \
    PRES_LENGTH_UNLIMITED, /* maxBatches */ \
    RTI_NTP_TIME_MAX, /* batchSrcTimestampRez */ \
    {0, 4294967}, /* minAckDelay (1ms) */ \
    {1, 0}, /* maxAckDelay (1 sec) */ \
    RTI_FALSE, /* enableAdaptiveAckDelay */ \
    {0, 429496}, /* minSeparation (100us) */ \
    128, /* cookieMaxBufferSize */ \
    PRES_LENGTH_UNLIMITED, /* sendWindowSize */ \
    PRES_UNREGISTERED_INSTANCE_REPLACEMENT, /* instanceReplacement */ \
    RTI_FALSE, /* replaceEmptyInstances */ \
    RTI_FALSE, /* enableVirtualHB */ \
    REDA_SEQUENCE_NUMBER_AUTO, /* initialVirtualSequenceNumber */ \
    1, /* initialVirtualWriters */ \
    -1, /* maxVirtualWriters */ \
    {PRES_TOPIC_PRESENTATION_QOS,RTI_FALSE,RTI_TRUE}, /* presentationQos */ \
    RTI_FALSE, /* allowOutOfOrderWrite */ \
    RTI_NTP_TIME_MAX, /* autopurgeUnregisteredInstancesDelay */ \
    RTI_NTP_TIME_MAX, /* autopurgeDisposedInstancesDelay */ \
    32UL, /* maxRemoteReaderFilters */\
    RTI_TRUE, /* storeFilterStatus. NOTE: Cannot be changed by API */\
    RTI_FALSE, /* useKeyOnlyReaderOptimization.*/\
    REDA_FAST_BUFFER_POOL_PROPERTY_DEFAULT, /* filteredReaderPoolP.*/\
    -1, /* maxRemoteReaders */ \
    -1, /* maxAppAckRemoteReaders */ \
    RTI_TRUE, /* keepReaderAckState */ \
    RTI_TRUE, /* propagateAppAckWithNoResponse */ \
    RTI_FALSE, /* supportsRequiredSubscriptions */ \
    PRES_WRITER_HISTORY_DRIVER_TURBO_MODE_PROPERTY_DEFAULT, /* turboMode */ \
    RTI_FALSE, /* use42eAlignment */ \
    RTI_FALSE, /* typeRequiresFilterOnSerialized */ \
    NULL, /* keyMaterialKey */ \
    RTI_FALSE, /* forceMD5KeyHash */ \
    MIG_GENERATOR_ENDIAN_UNKNOWN, /* endianness */ \
    RTI_FALSE, /* generateSampleSignature */ \
    0, /* nonce */ \
    NULL, /* topicName */ \
    NULL /* typeName */ \
   }

struct PRESWriterHistoryDriverSecurity {
    /* Participant used for interacting to the security forwarder. */
    struct PRESParticipant *participant;
    /* Key material for encoding and decoding. */
    void *senderCryptoHandle;
    /*
     * Buffer used for decoding the current sample. The memory associated to
     * it is provided by writer history's getSampleBuffer (using either
     * preAllocatedBuffer or dynamically allocated memory). Access to this
     * member must be protected by writer EA.
     */
    struct REDABuffer serializedSampleBuffer;
};


  #define PRES_WRITER_HISTORY_DRIVER_SECURITY_DEFAULT { \
    NULL, /* participant */\
    NULL, /* senderCryptoHandle */ \
    REDA_BUFFER_INVALID /* serializedSampleBuffer */ \
  }


#define PRES_WRITER_HISTORY_DRIVER_LISTENER_STORAGE_LENGTH (4)

struct PRESWriterHistoryDriverListener;

struct PRESWriterHistoryDriverListenerStorage {
    void *field[PRES_WRITER_HISTORY_DRIVER_LISTENER_STORAGE_LENGTH];
};

struct PRESWriterHistoryDriverListener;

typedef RTIBool
(*PRESWriterHistoryDriverListener_OnSampleRemovedCallback)(
    struct PRESWriterHistoryDriverListener * self,
    struct REDABuffer *cookie,
    struct PRESWriterHistoryDriverListenerStorage *storage
);

typedef RTIBool
(*PRESWriterHistoryDriverListener_OnInstanceReplacedCallback)(
    struct PRESWriterHistoryDriverListener * self,
    struct MIGRtpsKeyHash *keyHash,
    struct PRESWriterHistoryDriverListenerStorage *storage
);

typedef RTIBool
(*PRESWriterHistoryDriverListener_OnApplicationAcknowledgementCallback)(
    struct PRESWriterHistoryDriverListener * self,
    struct MIGRtpsGuid *writerGuid,
    struct REDASequenceNumber *vSn,
    struct REDABuffer *cookie,
    struct REDABuffer *response,
    RTIBool validResponse,
    struct MIGRtpsGuid *readerGuid,
    RTI_INT32 sessionId,
    struct REDASequenceNumber *sessionSn,
    struct PRESWriterHistoryDriverListenerStorage *storage,
    struct REDAWorker *worker
);

struct PRESWriterHistoryDriverListener {
    /* TODO: */

    PRESWriterHistoryDriverListener_OnSampleRemovedCallback
        onSampleRemoved;
    PRESWriterHistoryDriverListener_OnInstanceReplacedCallback
        onInstanceReplaced;
    PRESWriterHistoryDriverListener_OnApplicationAcknowledgementCallback
        onApplicationAcknowledgement;

};


  #define PRES_WRITER_HISTORY_DRIVER_ADD_FAILURE_INTERNAL (1)


  #define PRES_WRITER_HISTORY_DRIVER_ADD_FAILURE_RESOURCE_CONTENTION (2)


  #define PRES_WRITER_HISTORY_DRIVER_ADD_FAILURE_FULL (3)


  #define PRES_WRITER_HISTORY_DRIVER_ADD_FAILURE_OUT_OF_RESOURCES (4)


  #define PRES_WRITER_HISTORY_DRIVER_ADD_FAILURE_NO_INSTANCE (5)


  #define PRES_WRITER_HISTORY_DRIVER_ADD_FAILURE_TYPE_PLUGIN (6)


  #define PRES_WRITER_HISTORY_DRIVER_ADD_FAILURE_OUT_OF_ORDER (7)


  #define PRES_WRITER_HISTORY_DRIVER_ADD_FAILURE_LIFESPAN_EXPIRED (8)


  #define PRES_WRITER_HISTORY_DRIVER_BATCH_INCOMPATIBLE_SAMPLE_FAILURE (9)


   #define PRES_WRITER_HISTORY_DRIVER_BATCH_FULL_FAILURE (10)


  #define PRES_WRITER_HISTORY_DRIVER_GET_FAILURE_INTERNAL (11)


  #define PRES_WRITER_HISTORY_DRIVER_GET_FAILURE_NO_INSTANCE (12)


  #define PRES_WRITER_HISTORY_DRIVER_ADD_FAILURE_INSTANCE_FULL (13)


  #define PRES_WRITER_HISTORY_DRIVER_SAMPLE_DISCARDED (14)


  #define PRES_WRITER_HISTORY_DRIVER_ADD_FAILURE_SEND_WINDOW_FULL (15)


  #define PRES_WRITER_HISTORY_DRIVER_ADD_FAILURE_SEQUENCE_OUT_OF_ORDER (16)

extern PRESDllExport void
PRESWriterHistoryDriver_refilter(
    struct PRESWriterHistoryDriver *me,
    int filterIndex,
    struct PRESContentFilterQosPolicy *policy,
    RTI_INT32 sessionCount_in, RTI_INT32 sessionId_in[]);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_registerInstance(
    struct PRESWriterHistoryDriver *me, int *failReason,
    struct PRESInstanceHandle *handle, const void *instance,
    const struct PRESInstanceHandle *instanceHandle,
    const struct RTINtpTime *sourceTimestamp,
    const struct RTINtpTime *now, struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_registerInstanceX(
    struct PRESWriterHistoryDriver *me, int *failReason,
    struct PRESInstanceHandle *handle, const void *key,
    const struct RTINtpTime *sourceTimestamp,
    const struct RTINtpTime *now, struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_unregisterInstance(
    struct PRESWriterHistoryDriver *me, int *failReason,
    struct PRESOriginalWriterInfo * actualOriginalWriterInfo,
    struct REDASequenceNumber *firstAvailableSn,
    struct REDASequenceNumber *firstAvailableVirtualSn,
    struct MIGGeneratorSample **sample,
    RTI_UINT32 *sampleCount_out,
    RTI_INT32 *sessionId_out,
    const struct MIGRtpsGuid *readerGuid,
    const void *instance,
    const struct PRESInstanceHandle *handle,
    const struct PRESOriginalWriterInfo * originalWriterInfo,
    const struct PRESOriginalWriterInfo * relatedOriginalWriterInfo,
    const struct RTINtpTime *sourceTimestamp,
    const struct RTINtpTime *now,
    RTIBool ignoreSendWindow,
    RTI_INT32 publicationPriority,
    RTIBool autoRegister,
    PRESSampleFlag flag,
    struct PRESWriteParams * writeParams,
    struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_freeInstance(
    struct PRESWriterHistoryDriver *me, int *failReason,
    const void *instance,
    const struct PRESInstanceHandle *handle,
    struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_getKey(
    struct PRESWriterHistoryDriver *me, int *failReason, void *instance,
    const struct PRESInstanceHandle *handle, struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_getKeyX(
    struct PRESWriterHistoryDriver *me, int* failReason, void *key,
    const struct PRESInstanceHandle *handle, struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_assertAppAck(
    struct PRESWriterHistoryDriver *me,
    RTI_INT32 *failReason,
    struct MIGRtpsAppAckPerVirtualWriter *vwAppAck,
    const struct MIGRtpsGuid *remoteReaderGuid,
    const struct MIGRtpsGuid *remoteReaderVirtualGuid,
    RTI_INT32 sessionId,
    const struct RTINtpTime *now,
    struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_addWrite(
    struct PRESWriterHistoryDriver *me, int *failReason,
    struct PRESOriginalWriterInfo * actualOriginalWriterInfo,
    struct REDASequenceNumber *firstAvailableSn,
    struct REDASequenceNumber *firstAvailableVirtualSn,
    struct MIGGeneratorSample **sample,
    RTI_UINT32 *sessionCount_out,
    RTI_INT32 *sessionId_out,
    MIGGeneratorEndian endian,
    const struct MIGRtpsGuid *readerGuid,
    const struct PRESOriginalWriterInfo * originalWriterInfo,
    const struct PRESOriginalWriterInfo * relatedOriginalWriterInfo,
    const void *data,
    const struct PRESInstanceHandle *handle,
    const struct RTINtpTime *timestamp,
    const struct RTINtpTime *now,
    struct COMMENDFilterStatus *filterStatus,
    struct REDABuffer *cookie,
    RTIBool ignoreSendWindow,
    RTI_INT32 publicationPriority,
    PRESSampleFlag flag,
    /* TODO: Currently the only members used in writeParams are
     * relatedReaderGuid, relatedSourceGuid, and sourceGuid
     * We should use other members as well and remove parameters from this
     * function (see CORE-6494)
     */
    struct PRESWriteParams * writeParams,
    struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_addDispose(
    struct PRESWriterHistoryDriver *me, int *failReason,
    struct PRESOriginalWriterInfo * actualOriginalWriterInfo,
    struct REDASequenceNumber *firstAvailableSn,
    struct REDASequenceNumber *firstAvailableVirtualSn,
    struct MIGGeneratorSample **sample,
    RTI_UINT32 *sessionCount_out,
    RTI_INT32 *sessionId_out,
    const struct MIGRtpsGuid *readerGuid,
    const struct PRESOriginalWriterInfo * originalWriterInfo,
    const struct PRESOriginalWriterInfo * relatedOriginalWriterInfo,
    const void *data,
    const struct PRESInstanceHandle *handle,
    const struct RTINtpTime *timestamp, const struct RTINtpTime *now,
    RTIBool ignoreSendWindow,
    RTI_INT32 publicationPriority,
    PRESSampleFlag flag,
    struct PRESWriteParams * writeParams,
    struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_addHistorical(
    struct PRESWriterHistoryDriver *me, int *failReason,
    struct MIGGeneratorSample **sample,
    struct REDASequenceNumber *firstAvailableSn,
    struct REDASequenceNumber *firstAvailableVirtualSn,
    RTI_INT32 *sessionId_out,
    const struct NDDS_WriterHistory_Sample * existingSample,
    const struct RTINtpTime * timestamp,
    MIGGeneratorEndian endian,
    const struct MIGRtpsGuid * topicQueryGuid,
    const struct MIGRtpsGuid * readerGuid,
    RTIBool lastSampleInQuery,
    const struct RTINtpTime *now,
    RTIBool ignoreSendWindow,
    struct REDAWorker *worker);

extern PRESDllExport void
PRESWriterHistoryDriver_finish(
    struct PRESWriterHistoryDriver *me, struct MIGGeneratorSample *sample,
    const struct RTINtpTime *now, struct REDAWorker *worker);

extern PRESDllExport void
PRESWriterHistoryDriver_beginCoherentChanges(struct PRESWriterHistoryDriver *me);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_endCoherentChanges(
    struct PRESWriterHistoryDriver *me, int *failReason,
    struct MIGGeneratorSample **sample,
    RTI_UINT32 *sampleCount_out,
    RTI_INT32 *sessionId_out);

extern PRESDllExport void
PRESWriterHistoryDriver_beginInstanceIteration(struct PRESWriterHistoryDriver *me);

extern PRESDllExport void
PRESWriterHistoryDriver_endInstanceIteration(struct PRESWriterHistoryDriver *me);

extern PRESDllExport struct PRESWriterHistoryDriverInstance *
PRESWriterHistoryDriver_getInstanceIteration(struct PRESWriterHistoryDriver *me);

extern PRESDllExport void
PRESWriterHistoryDriver_getInstanceHandle(
    struct PRESWriterHistoryDriver *me,
    struct PRESInstanceHandle *handle,
    struct PRESWriterHistoryDriverInstance *instance);

extern PRESDllExport RTIBool PRESWriterHistoryDriver_checkDeadline(
    struct PRESWriterHistoryDriver *me,
    int * deadlineMissedCount,
    struct PRESInstanceHandle * lastHandle,
    struct RTINtpTime * minNextDeadline,
    const struct RTINtpTime *now);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_requestData(
    struct PRESWriterHistoryDriver *me,
    struct MIGGeneratorSample **sample, RTIBool *dataValid,
    struct REDASequenceNumber *firstRelevantSn,
    struct REDASequenceNumber *nextRelevantSn,
    struct REDASequenceNumber *firstRelevantVirtualSn,
    struct REDASequenceNumber *nextRelevantVirtualSn,
    const struct REDASequenceNumber *requestSn,
    const struct RTINtpTime *now,
    int filterIndex,
    struct COMMENDFilterStatus *filterStatus,
    struct PRESContentFilterQosPolicy *policy,
    RTI_INT32 sessionId_in,
    const struct MIGRtpsGuid *remoteReaderVirtualGuid,
    struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_completeBeAsynchPubBySample(
    struct PRESWriterHistoryDriver *me,
    struct MIGGeneratorSample *completedSample,
    RTI_INT32 sessionId,
    const struct RTINtpTime *now, /* optional */
    struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_completeBeAsynchPub(
    struct PRESWriterHistoryDriver *me,
    const struct REDASequenceNumber *completedSn,
    RTI_INT32 sessionId,
    const struct RTINtpTime *now,
    struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_completeBeAsynchPubAndPrior(
    struct PRESWriterHistoryDriver *me,
    const struct REDASequenceNumber *completedSn,
    RTI_INT32 sessionId,
    const struct RTINtpTime *now, /* optional */
    struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_changeFirstUnackedSn(
    struct PRESWriterHistoryDriver *me,
    struct REDASequenceNumber *firstUnackedVirtualSn, /* output */
    const struct REDASequenceNumber *firstUnackedSn,
    RTI_INT32 sessionId,
    const struct MIGRtpsGuid *readerVirtualGuid,
    const RTIBool durSubOnly,
    const struct RTINtpTime *now,
    struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_checkSampleKeepDuration(
    struct PRESWriterHistoryDriver *me,
    struct REDASequenceNumber *firstNonElapsedSn,
    struct RTINtpTime *firstNonElapsedTs,
    const struct RTINtpTime *expirationTime,
    RTI_INT32 sessionCount, RTI_INT32 sessionId[],
    struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_getLastAvailableSn(
    struct PRESWriterHistoryDriver *me,
    struct REDASequenceNumber *lastAvailableSn,
    RTI_INT32 sessionCount, RTI_INT32 sessionId[],
    struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_getFirstNonReclaimableSn(
    struct PRESWriterHistoryDriver *me,
    struct REDASequenceNumber *firstNonReclaimableSn,
    struct RTINtpTime *firstNonReclaimableTimestamp,
    RTI_INT32 sessionCount, RTI_INT32 sessionId[],
    struct REDAWorker *worker);

extern PRESDllExport void
PRESWriterHistoryDriver_setDeadlinePeriod(
    struct PRESWriterHistoryDriver *me,
    const struct RTINtpTime *deadlinePeriod);

extern PRESDllExport void
PRESWriterHistoryDriver_lookupInstance(struct PRESWriterHistoryDriver *me,
                                   const void* key_holder,
                                   struct PRESInstanceHandle *handle);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_getInstance(struct PRESWriterHistoryDriver *me,
                                    const void* key_holder,
                                    const struct PRESInstanceHandle *myHandle,
                                    struct NDDS_WriterHistory_Instance **instance,
                                    RTIBool returnInstanceLoan_in);

extern PRESDllExport void
PRESWriterHistoryDriver_returnInstanceLoan(struct PRESWriterHistoryDriver *me,
                                           struct NDDS_WriterHistory_Instance *instance);

extern PRESDllExport void
PRESWriterHistoryDriver_lookupInstanceX(struct PRESWriterHistoryDriver *me,
                                   const void* key_holder,
                                   struct PRESInstanceHandle *handle);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_pruneLifespanExpiredEntries(
    struct PRESWriterHistoryDriver *me,
    struct REDASequenceNumber *firstSn, struct REDASequenceNumber *firstVirtualSn,
    RTI_INT32 sessionId_in,
    const struct RTINtpTime *now,
    RTIBool singleEntry,
    struct REDAWorker *worker);

extern PRESDllExport void
PRESWriterHistoryDriver_setLifespan(
    struct PRESWriterHistoryDriver *me,
    const struct PRESLifespanQosPolicy *lifespanQos,
    const struct RTINtpTime *now);

extern PRESDllExport void
PRESWriterHistoryDriver_setAutopurgeInstanceOnUnregisterDelay(
    struct PRESWriterHistoryDriver *me,
    const struct RTINtpTime * autoPurgeInstanceOnUnDelay);

extern PRESDllExport void
PRESWriterHistoryDriver_setAutopurgeInstanceOnDisposeDelay(
    struct PRESWriterHistoryDriver *me,
    const struct RTINtpTime * autoPurgeInstanceOnDisposeDelay);

extern PRESDllExport void
PRESWriterHistoryDriver_setSampleKeepDuration(
    struct PRESWriterHistoryDriver *me,
    const struct RTINtpTime *minKeepDuration,
    const struct RTINtpTime *maxKeepDuration);

extern PRESDllExport void
PRESWriterHistoryDriver_scaleSampleKeepDuration(
    struct PRESWriterHistoryDriver *me,
    const struct RTINtpTime *keepDuration);

extern PRESDllExport void
PRESWriterHistoryDriver_setSendWindowSize(
    struct PRESWriterHistoryDriver *me,
    RTI_INT32 *currentSendWindowOut,
    RTI_INT32 sendWindowSize,
    RTI_INT32 sessionId);

extern PRESDllExport void
PRESWriterHistoryDriver_getNonReclaimableCount(
    struct PRESWriterHistoryDriver *me,
    RTI_INT32 *count_out,
    RTI_INT32 sessionCount_in, RTI_INT32 sessionId[]);

extern PRESDllExport void
PRESWriterHistoryDriver_getAppAckNonReclaimableCount(
    struct PRESWriterHistoryDriver *me,
    RTI_INT32 *count_out,
    RTI_INT32 sessionCount_in, RTI_INT32 sessionId[]);

extern PRESDllExport void
PRESWriterHistoryDriver_getHighestReclaimableSn(
    struct PRESWriterHistoryDriver *me,
    struct REDASequenceNumber * sn,
    RTI_INT32 sessionCount_in, RTI_INT32 sessionId_in[]);

extern RTIBool PRESWriterHistoryDriver_enable(
    struct PRESWriterHistoryDriver * me,
    RTI_INT32 sessionCount, RTI_INT32 sessionId[],
    const struct RTINtpTime* nowIn);


extern	RTIBool PRESWriterHistoryDriver_serializeSampleInBatch(
    struct PRESWriterHistoryDriver *me, int *failReason,
    struct PRESOriginalWriterInfo * actualOriginalWriterInfo,
    RTIBool * flushBatch,
    PRESWriterHistoryDriverSampleKind kind,
    MIGGeneratorEndian endian,
    const struct MIGRtpsGuid * readerGuid,
    const struct PRESOriginalWriterInfo * originalWriterInfo,
    const struct PRESOriginalWriterInfo * relatedOriginalWriterInfo,
    const void *data,
    const struct PRESInstanceHandle *handle,
    const struct RTINtpTime *timestamp,
    RTI_INT32 publicationPriority,
    PRESSampleFlag flag,
    struct PRESWriteParams * writeParams,
    struct REDAWorker *worker);

struct PRESTypePluginData;

extern PRESDllExport struct PRESWriterHistoryDriver *
PRESWriterHistoryDriver_new(
    struct REDASequenceNumber * firstSn,
    struct REDASequenceNumber * lastSn,
    struct REDASequenceNumber * lowestUnackSn,
    const struct PRESWriterHistoryDriverProperty *property,
    const struct MIGRtpsGuid *guid,
    const struct MIGRtpsGuid *virtualGuid,
    struct PRESOriginalWriterInfo * groupInfo,
    struct PRESSequenceEndpointGroup *requiredMatchedEndpointGroups,
    const struct PRESSequenceProperty * dpProperties,
    const struct PRESSequenceProperty * dwProperties,
    const struct PRESTypePlugin *typePlugin,
    PRESTypePluginEndpointData endpointData,
    const char * whPluginName,
    struct NDDS_WriterHistory_Plugin * whPlugin,
    RTI_INT32 sessionCount, RTI_INT32 sessionId[],
    struct RTIClock *clock,
    struct RTIClock *timestampClock,
    RTI_INT32 encapsulationCount,
    struct RTIEncapsulationInfo encapsulationInfo[],
    struct PRESWriterHistoryDriverListener *listener_in,
    struct PRESWriterHistoryDriverListenerStorage *storage,
    const struct REDAExclusiveArea * publisherEA,
    struct PRESWriterHistoryDriverSecurity *security);

extern RTIBool PRESWriterHistoryDriver_setDurableSubscriptions(
    struct PRESWriterHistoryDriver *me,
    struct PRESEndpointGroup *buffer,
    RTI_UINT32 length,
    struct REDAWorker *worker);

extern PRESDllExport void
PRESWriterHistoryDriver_delete(struct PRESWriterHistoryDriver *me);


extern	RTIBool PRESWriterHistoryDriver_getStatistics(
        struct PRESWriterHistoryDriver* me,
        struct NDDS_WriterHistory_Statistics *stats);


extern	RTIBool PRESWriterHistoryDriver_setStatistics(
        struct PRESWriterHistoryDriver* me,
        const struct NDDS_WriterHistory_Statistics *stats);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_flush(
    struct PRESWriterHistoryDriver *me, int *failReason,
    struct REDASequenceNumber *firstAvailableSn,
    struct REDASequenceNumber *firstAvailableVirtualSn,
    struct MIGGeneratorSample **sample,
    RTI_UINT32 * sampleCount, /* Out */
    RTI_INT32 * sessionId, /* Out */
    const struct RTINtpTime * now,
    RTIBool ignoreSendWindow,
    struct REDAWorker *worker);

extern PRESDllExport
struct MIGGeneratorSample *
    PRESWriterHistoryDriver_getBatchInProgress(
        struct PRESWriterHistoryDriver *me,
        RTIBool * flushBatch);

extern PRESDllExport
int PRESWriterHistoryDriver_getKeyKind(
    struct PRESWriterHistoryDriver * me);

extern PRESDllExport
PRESPresentationQosPolicyAccessScopeKind PRESWriterHistoryDriver_getAccessScope(
    struct PRESWriterHistoryDriver * me);

extern PRESDllExport
PRESServiceQosPolicyKind PRESWriterHistoryDriver_getServiceKind(
    struct PRESWriterHistoryDriver * me);

extern PRESDllExport
RTI_UINT32 PRESWriterHistoryDriver_getSessionCount(
    struct PRESWriterHistoryDriver * me);

extern PRESDllExport
RTI_INT32* PRESWriterHistoryDriver_getSessions(
    struct PRESWriterHistoryDriver * me);

extern PRESDllExport
RTIBool PRESWriterHistoryDriver_setSampleKeepDurationMode(
    struct PRESWriterHistoryDriver * me,
    RTI_INT32 sessionCount, RTI_INT32 sessionId[],
    RTIBool ackEnabledReaderPresent,
    RTIBool ackDisabledReaderPresent);

extern PRESDllExport
RTIBool PRESWriterHistoryDriver_use42eAlignment(
    struct PRESWriterHistoryDriver * me);

extern PRESDllExport
RTIBool PRESWriterHistoryDriver_serializeSample(
    struct PRESWriterHistoryDriver *me,
    int *failReason,
    struct REDABuffer *buffer,
    struct MIGGeneratorSample * sample,
    RTIEncapsulationId encapsulationId,
    struct REDAWorker *worker);

extern PRESDllExport
RTIBool PRESWriterHistoryDriver_returnSerializationBuffer(
    struct PRESWriterHistoryDriver *me,
    int *failReason,
    struct REDABuffer *buffer,
    RTIEncapsulationId encapsulationId,
    struct REDAWorker *worker);

extern PRESDllExport
RTIBool PRESWriterHistoryDriver_assertRemoteReader(
    struct PRESWriterHistoryDriver *me,
    const struct MIGRtpsGuid *remoteReaderGuid,
    const struct MIGRtpsGuid *remoteReaderVirtualGuid,
    const char * roleName,
    RTI_INT32 sessionId,
    PRESReliabilityQosPolicyAcknowledgmentModeKind ackMode,
    RTIBool readerIsActive,
    struct REDAWorker *worker);

extern PRESDllExport
RTIBool PRESWriterHistoryDriver_removeRemoteReader(
    struct PRESWriterHistoryDriver *me,
    const struct MIGRtpsGuid *remoteReaderGuid,
    const struct MIGRtpsGuid *remoteReaderVirtualGuid,
    RTI_INT32 sessionId,
    PRESReliabilityQosPolicyAcknowledgmentModeKind ackMode,
    struct REDAWorker *worker);

extern PRESDllExport
RTIBool PRESWriterHistoryDriver_getWriterInfo(
    struct PRESWriterHistoryDriver *me,
    struct MIGRtpsWriterInfo **writerInfo, RTI_INT32 sessionId);

extern PRESDllExport
struct PRESOriginalWriterInfo * PRESWriterHistoryDriver_getGroupInfo(
    struct PRESWriterHistoryDriver *me);


extern	RTIBool PRESWriterHistoryDriver_addFilteredReaderToInstance(
    struct PRESWriterHistoryDriver * me,
    struct NDDS_WriterHistory_Instance * instance,
    const struct REDAWeakReference *filteredwrrWR);


extern	void PRESWriterHistoryDriver_removeFilteredReaderFromInstance(
    struct PRESWriterHistoryDriver * me,
    struct NDDS_WriterHistory_Instance * instance,
    struct REDAInlineListNode *node);


extern	void PRESWriterHistoryDriver_resetFilteredReaderList(
    struct PRESWriterHistoryDriver * me,
    struct NDDS_WriterHistory_Instance * instance);

extern PRESDllExport
RTIBool PRESWriterHistoryDriver_getDurableSubscriptionInfo(
    struct PRESWriterHistoryDriver *me,
    struct NDDS_WriterHistory_DurableSubscription ** durSub,
    const char * durSubName);

extern PRESDllExport
RTIBool PRESWriterHistoryDriver_setDurableSubscriptionInfo(
    struct PRESWriterHistoryDriver *me,
    const struct NDDS_WriterHistory_DurableSubscription * durSub);

extern PRESDllExport
void PRESWriterHistoryDriver_setListener(
        struct PRESWriterHistoryDriver * me,
        struct PRESWriterHistoryDriverListener *listener);


#ifdef __cplusplus
    }	/* extern "C" */
#endif

#endif /* pres_writerHistoryDriver_h */
