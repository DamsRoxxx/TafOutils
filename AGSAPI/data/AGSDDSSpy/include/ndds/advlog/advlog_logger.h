/* (c) Copyright 2003-2015, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)advlog_logger.h    generated by: makeheader    Fri Feb 16 13:51:21 2018
 *
 *		built from:	logger.ifc
 */

#ifndef advlog_logger_h
#define advlog_logger_h


  #include <stdlib.h>
  #include <stdio.h>

  #ifndef osapi_thread_h
    #include "osapi/osapi_thread.h"
  #endif

  #ifndef reda_worker_h
    #include "reda/reda_worker.h"
  #endif
  
  #ifndef advlog_dll_h
    #include "advlog/advlog_dll.h"
  #endif

  #ifndef log_common_h
    #include "log/log_common.h"
  #endif
  #ifndef clock_interface_h
    #include "clock/clock_interface.h"
  #endif

  #ifdef __cplusplus
    extern "C" {
  #endif

struct ADVLOGMessageInfo;


#define ADVLOG_NUM_BULTIN_DEVICE_KINDS (3)


#define ADVLOG_LOGGER_MAX_DEVICES (10)


  #define ADVLOG_LOGGER_MESSAGE_COUNT_MAX  10      /* max number of errors or warnings 
                                                      stored in the queue*/

typedef enum {
    /* WARNING: any changes to this must be reflected in  
       ADVLOG_NUM_BULTIN_DEVICE_KINDS */
    ADVLOG_LOGGER_SLOT_MEMORY   = 1,
    ADVLOG_LOGGER_SLOT_FILE     = 3,
    ADVLOG_LOGGER_SLOT_STDIO    = 7
    /* WARNING: any changes to this must be reflected in  
       ADVLOG_NUM_BULTIN_DEVICE_KINDS */
} ADVLOGLoggerBuiltinSlotValues ;

struct ADVLOGLoggerDevice;

typedef void (*ADVLOGLoggerDeviceWriteFnc)(
        struct ADVLOGLoggerDevice *device,
        struct REDAWorker *worker,
        const  struct ADVLOGMessageInfo *msg);

typedef void (*ADVLOGLoggerDeviceCloseFnc)(
        struct ADVLOGLoggerDevice *device,
        struct REDAWorker *worker);


struct ADVLOGLoggerDevice {
    /*e Identify device. Number below 100 are reserved for built-in devices.*/
    int deviceKind;
    /*e Write a logged message to this device.*/
    ADVLOGLoggerDeviceWriteFnc writeFnc;
    /*e Close this device.*/
    ADVLOGLoggerDeviceCloseFnc closeFnc;
};

struct ADVLOGWorkerProvider;

typedef struct REDAWorker *(*ADVLOGWorkerProviderGetWorkerFunction)(
        struct ADVLOGWorkerProvider *self);

typedef void (*ADVLOGWorkerProviderAssociateWorkerFunction)(
        struct ADVLOGWorkerProvider *self,
        struct REDAWorker *worker);

struct ADVLOGWorkerProvider {
    ADVLOGWorkerProviderGetWorkerFunction getWorker;
    ADVLOGWorkerProviderAssociateWorkerFunction associateWorker;
    void *data;
};

struct ADVLOGMessageInfo {
    char message[RTI_LOG_MSG_SIZE_MAX];
    RTILogBitmap logLevel;
};

extern ADVLOGDllExport
RTIBool ADVLOGLogger_preinit();

extern ADVLOGDllExport
RTIBool ADVLOGLogger_init(struct REDAWorkerFactory *workerFactory,
                          struct ADVLOGWorkerProvider *workerProvider,
                          struct RTIClock *timestampClock,
                          RTIOsapiThreadTssFactory * tssFactory);

extern ADVLOGDllExport
RTIBool ADVLOGLogger_install();

extern ADVLOGDllExport
RTIBool ADVLOGLogger_uninstall();

extern ADVLOGDllExport
RTIBool ADVLOGLogger_finalize(struct REDAWorker * worker);

extern ADVLOGDllExport
RTIBool ADVLOGLogger_setDevice(int slot, struct ADVLOGLoggerDevice *device,
        struct REDAWorker *worker, RTIBool workerSpecific);

extern ADVLOGDllExport
RTI_UINT32 ADVLOGLogger_getPrintMask(
        struct REDAWorker *worker, RTIBool workerSpecific);

extern ADVLOGDllExport
RTIBool ADVLOGLogger_setPrintMask(RTI_UINT32 mask,
        struct REDAWorker *worker, RTIBool workerSpecific);

extern ADVLOGDllExport
RTIBool ADVLOGLogger_setDeviceBuiltinFile(FILE *file,
        RTI_UINT32 maxCapacity, struct REDAWorker *worker, RTIBool workerSpecific);

extern ADVLOGDllExport
RTIBool ADVLOGLogger_setDeviceBuiltinMemory(char *buffer,
        RTI_UINT32 maxCapacity, struct REDAWorker *worker, RTIBool workerSpecific);

extern ADVLOGDllExport
RTIBool ADVLOGLogger_setDeviceBuiltinStdio(struct REDAWorker *worker,
                                           RTIBool workerSpecific);

extern ADVLOGDllExport
RTIBool ADVLOGLogger_setThreadLogAlsoToGlobal(struct REDAWorker *worker,
                                              RTIBool sendAlsoToGlobal);


/*e Define bits used by RTILOG
   @brief non-ADVLOG print bit mask
*/
#define ADVLOG_PRINT_MASK_RTILOG     0x00ff
/*e Define bits used by ADVLOG
   @brief ADVLOG-only print bit mask
*/
#define ADVLOG_PRINT_MASK            0xff00

/* \ingroup ADVLOGLoggerPrintBitmapClass
   @brief Print a timestamp
*/
#define ADVLOG_PRINT_BIT_TIMESTAMP   0x100
/* \ingroup ADVLOGLoggerPrintBitmapClass
   @brief Print thread ID
*/
#define ADVLOG_PRINT_BIT_THREAD_ID   0x200
/* \ingroup ADVLOGLoggerPrintBitmapClass
   @brief Print the context stack state
*/
#define ADVLOG_PRINT_BIT_CONTEXT     0x400
/* \ingroup ADVLOGLoggerPrintBitmapClass
   @brief Print the context stack state
*/
#define ADVLOG_PRINT_BIT_TWO_LINES   0x800

/* \ingroup ADVLOGLoggerPrintBitmapClass
   @brief Default ADVLOG print mask
*/
#define ADVLOG_PRINT_MASK_DEFAULT    (ADVLOG_PRINT_BIT_CONTEXT)

/* \ingroup ADVLOGLoggerPrintBitmapClass
   @brief ADVLOG print mask value to force use of global default
*/
#define ADVLOG_PRINT_MASK_USE_DEFAULT    0xffff


/*e \ingroup ADVLOGLoggerModule

   @brief register a worker to be associated with the current thread
*/
extern ADVLOGDllExport
RTIBool ADVLOGLogger_associateWorkerWithCurrentThread(struct REDAWorker *worker);


/*i \ingroup ADVLOGLoggerModule

   @brief ADVLOG version of printContextAndMsg [NOT YET IMPLEMENTED]

   If worker is NULL, it will be looked up; this is functionally equivalent
   to calling the RTILog version of this function when ADVLOG is installed.

   If ADVLOG has not yet been initialized, the call is passed to RTILog.
*/
Peer ADVLOGDllExport
RTIBool ADVLOGLogger_printContextAndMsg(struct REDAWorker *worker,
                                        const char *context,
                                        const struct RTILogMessage *errMsg, ...);

/*i \ingroup ADVLOGLoggerModule

   @brief ADVLOG version of printLocationContextAndMsg [NOT YET IMPLEMENTED]

   If worker is NULL, it will be looked up; this is functionally equivalent
   to calling the RTILog version of this function when ADVLOG is installed.

   If ADVLOG has not yet been initialized, the call is passed to RTILog.
*/
Peer ADVLOGDllExport
RTIBool ADVLOGLogger_printLocationContextAndMsg(struct REDAWorker *worker,
                                        RTI_UINT32 module, const char *filename,
                                        const char *method, RTI_UINT32 lineno,
                                        const struct RTILogMessage *errMsg, ...);

/*e \ingroup ADVLOGLoggerModule

   @brief Function to explicitly output timestamp.

   If worker is NULL, it will be looked up.

   If ADVLOG has not yet been initialized, the call will fail.
*/
extern ADVLOGDllExport
RTIBool ADVLOGLogger_printTimestamp(struct REDAWorker *worker,
                                    const char *context);


/*e \ingroup ADVLOGLoggerModule 
   @brief This method will return the last n error or warning messages or
   simply calculate the amount of space needed to hold the last n error
   messages.
 
   If worker is NULL, it will be looked up.
 
   If stackMessage is NULL then the length will be calcualted and returned in
   len. Otherwise, stackMessage will be populated with the last n error or
   warnign messages, each on their own line, with increasing indentation. 
 
   If stackMessage is NULL, len will be returned with the length needed to store
   the last n error or warning messages. Otherwise, len should equal the amount
   of available space and the actual length of the string will be returned. 

   If ADVLOG has not yet been initialized, the call will fail.
*/ 
extern ADVLOGDllExport
void ADVLOGLogger_getLastErrorMessages(
   struct REDAWorker *worker, char* stackMessage, RTI_INT32 *size);


/* The messageInfos for errors and warning are stored in the
   logger as a circular queue. The circular queue is implemented
   on top of an array of messageInfo structure. Whenever a new
   error/warning is encountered the start index of the array is
   advanced and the information about the error or the warning
   is then stored in the location pointed by the start index.
*/

/*e \ingroup ADVLOGLoggerModule 
   @brief This method will clear the ADVLOGMessageInfo queue
   associated with the worker.
 
   If worker is NULL, it will be looked up.

   If ADVLOG has not yet been initialized, the call will fail.
*/ 
extern ADVLOGDllExport
void
ADVLOGLogger_emptyMessageInfoQueue(struct REDAWorker *worker);


extern ADVLOGDllExport
struct REDAWorker* ADVLOGLogger_getWorker(void);




  #ifdef __cplusplus
    }	/* extern "C" */
  #endif

#endif /* advlog_logger_h */
