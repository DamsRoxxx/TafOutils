/* (c) Copyright 2003-2015, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)netio_sender.h    generated by: makeheader    Fri Feb 16 13:51:35 2018
 *
 *		built from:	sender.ifc
 */

#ifndef netio_sender_h
#define netio_sender_h


  #ifndef netio_dll_h
    #include "netio/netio_dll.h"
  #endif
  #ifndef netio_log_h
    #include "netio/netio_log.h"
  #endif
  #ifndef netio_common_h
    #include "netio/netio_common.h"
  #endif
  #ifndef netio_configurator_h
    #include "netio/netio_configurator.h"
  #endif  

#ifdef __cplusplus
    extern "C" {
#endif

struct RTIClock;

struct REDABuffer;

struct REDAExclusiveArea;

struct REDAWorker;

struct REDAWeakReference;

struct REDADatabase;

struct RTINetioSenderProperty {
    /*e Control destination table growth.  Helps avoid memory allocation. */
    struct REDAFastBufferPoolGrowthProperty destinationGrowth;

    /*e Control resource table growth.  Helps avoid memory allocation. */
    struct REDAFastBufferPoolGrowthProperty resourceGrowth;

    /*e Control smart destination reference growth.
	  Helps avoid memory allocation.
       Any destination that is chained with reference (reliable writer without
       content filtered topic) will use this whether the resource is shared or
       not, so this is expected to grow faster than the destination or the
       underlying resource.  I would recommend at least 8 times the
       destinationGrowth.
    */
    struct REDAFastBufferPoolGrowthProperty destinationReferenceGrowth;
};


#define RTI_NETIO_SENDER_PROPERTY_DEFAULT {  \
    {32, REDA_FAST_BUFFER_POOL_UNLIMITED, REDA_FAST_BUFFER_POOL_UNLIMITED}, \
    {2*32, REDA_FAST_BUFFER_POOL_UNLIMITED, REDA_FAST_BUFFER_POOL_UNLIMITED}, \
    {8*32, REDA_FAST_BUFFER_POOL_UNLIMITED, REDA_FAST_BUFFER_POOL_UNLIMITED}, }

struct RTINetioSenderDestinationGroup;

extern RTINetioDllExport RTIBool
RTINetioSenderDestinationGroup_queryCapability(
    struct RTINetioSenderDestinationGroup *me,
    int *messageSizeMaxOut, int *gatherBufferCountMaxOut,
    struct REDAWorker *worker);

extern RTINetioDllExport RTIBool RTINetioSenderDestinationGroup_sendFast(
    struct RTINetioSenderDestinationGroup *me,
    const struct REDABuffer *bufferIn, int bufferCountIn,
    int transportPriority, struct REDAWorker *worker);

struct RTINetioSender;

extern RTINetioDllExport struct RTINetioSenderDestinationGroup *
RTINetioSender_createDestinationGroup(struct RTINetioSender *me);

extern RTINetioDllExport void RTINetioSender_destroyDestinationGroup(
    struct RTINetioSender *me, struct RTINetioSenderDestinationGroup *group);

extern RTINetioDllExport RTIBool RTINetioSender_sendFast(
    struct RTINetioSender *me,
    const struct REDAWeakReference *destinationArrayIn, 
    int destinationCountIn,
    const struct REDABuffer *bufferIn, int bufferCountIn,
    int transportPriority, struct REDAWorker *worker);

extern RTINetioDllExport RTIBool RTINetioSender_addDestination(
    struct RTINetioSender *me,
    RTIBool* foundMoreThanProvidedForOut,
    int *pluginArrayLengthInOut,
    NDDS_Transport_Plugin **pluginArrayInOut,
    int pluginArrayCapacityIn,
    struct REDAWeakReference *destinationWROut,
    struct RTINetioSenderDestinationGroup *destinationGroupInOut,
    const struct RTINetioLocatorInfo* destinationIn,
    struct REDAWorker *worker);

extern RTINetioDllExport void RTINetioSender_removeDestination(
    struct RTINetioSender *me,
    struct RTINetioSenderDestinationGroup *destinationGroupInOut,
    const struct REDAWeakReference *destinationWRIn, 
    struct REDAWorker *worker);

extern RTINetioDllExport RTIBool
RTINetioSender_queryCapability(
    struct RTINetioSender *me,
    int *messageSizeMaxOut, int *gatherBufferCountMaxOut,
    const struct REDAWeakReference *destinationArrayIn, 
    int destinationCountIn,
    struct REDAWorker *worker);

extern RTINetioDllExport RTIBool 
RTINetioSender_getLocatorFromWR(
    struct RTINetioSender *me,
    struct RTINetioLocator *locatorOut,
    struct REDAWeakReference *locatorWR,
    struct REDAWorker *worker);

extern RTINetioDllExport RTIBool
RTINetioSender_shutdown(struct RTINetioSender *me,
			struct REDAWorker *worker);

extern RTINetioDllExport void
RTINetioSender_delete(struct RTINetioSender *me,
                      struct REDAWorker *worker);

extern RTINetioDllExport struct RTINetioSender *
RTINetioSender_new(struct RTIClock *clockIn, struct REDAExclusiveArea* tableEa,
		   struct REDADatabase *dbIn,
		   struct RTIEventActiveObjectListener *shutdownListenerIn,
		   struct RTINetioConfigurator* configuratorIn,
		   const struct RTINetioSenderProperty *propertyIn,
		   struct REDAWorker *worker);


#ifdef __cplusplus
    }	/* extern "C" */
#endif

  #include "netio/netio_sender_impl.h"

#endif /* netio_sender_h */
