/* (c) Copyright 2003-2015, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)osapi_socket.h    generated by: makeheader    Fri Feb 16 13:51:09 2018
 *
 *		built from:	socket.ifc
 */

#ifndef osapi_socket_h
#define osapi_socket_h


  #include <errno.h>

  /* Architectures that require u_char (standard POSIX header) */
  #if (defined(RTI_UNIX) || defined(RTI_VXWORKS) || defined(RTI_LYNX) ||\
       defined(RTI_QNX) || defined(RTI_INTY) || defined(RTI_OPENVMS))
    #include <sys/types.h>
  #endif

  #if (defined(RTI_QNX))
	#include  <sys/select.h> 
  #endif

  #if (defined(RTI_VXWORKS) || defined(RTI_LYNX))
    #if (defined(RTI_VX653))
      #include <sys/socket.h>
    #endif
    #include <netinet/in.h>
  #elif defined(RTI_INTY)
    #include <unistd.h>
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <arpa/inet.h>
  #elif (defined(RTI_UNIX) || defined(RTI_QNX))
    #include <arpa/inet.h>
    #include <unistd.h>
    #include <sys/socket.h>
  #elif (defined(RTI_WIN32) || defined(RTI_WINCE))
    #include <winsock2.h>
    #include <ws2tcpip.h>
  #endif

  #if defined(RTI_VXWORKS)
    #include <ioLib.h>
    #if !defined(RTI_VX653)
      #include <sockLib.h>
    #endif
  #elif defined(RTI_LYNX)
    #include <unistd.h>
    #if !defined(RTI_LYNXOS_SE) && !defined(RTI_LYNX500)
        #include <socket.h>
    #endif
  #endif

  #ifndef log_common_h
    #include "log/log_common.h"
  #endif
  #ifndef osapi_log_h
    #include "osapi/osapi_log.h"
  #endif
  #ifndef osapi_type_h
    #include "osapi/osapi_type.h"
  #endif

#ifdef __cplusplus
    extern "C" {
#endif

  #if defined(RTI_VX653)
    #if (RTI_VX653 == 2501)
      struct sockaddr;
    #endif
    struct sockaddr_in;
    struct in_addr;
    #if (RTI_VX653 != 2501)
      typedef unsigned int socklen_t;
    #endif
  #endif 
 

extern RTIOsapiDllExport RTIBool RTIOsapiSocketModule_init();

extern RTIOsapiDllExport void RTIOsapiSocketModule_finalize();

typedef enum {
    RTI_OSAPI_SOCKET_TYPE_UDPv4      = 0x00,
    RTI_OSAPI_SOCKET_TYPE_TCPv4      = 0x01,
    RTI_OSAPI_SOCKET_TYPE_UDPv4_OVL  = 0x02,
    RTI_OSAPI_SOCKET_TYPE_TCPv4_OVL  = 0x03,
    RTI_OSAPI_SOCKET_TYPE_UDPv6      = 0x10,
    RTI_OSAPI_SOCKET_TYPE_TCPv6      = 0x11
} RTIOsapiSocketType;

extern RTIOsapiDllExport int RTIOsapiSocket_create(RTIOsapiSocketType socketType);


#define RTI_OSAPI_SOCKET_BUFFER_SIZE_OS_DEFAULT (-1)

typedef RTI_UINT32 RTIOsapiSocketAFKind;

typedef RTI_UINT32 RTIOsapiSocketAFMask;


  #define RTI_OSAPI_SOCKET_AF_INET  (RTIOsapiSocketAFKind)(0x0001 << 0)
  #define RTI_OSAPI_SOCKET_AF_INET6 (RTIOsapiSocketAFKind)(0x0001 << 1)
  #define RTI_OSAPI_SOCKET_AF_MASK_NONE (RTIOsapiSocketAFKind)(0x0)

extern RTIOsapiDllExport
int RTIOsapiSocket_addressFamilyFromKind(RTIOsapiSocketAFKind kind);

/*e \ingroup RTIOsapiSocketClass
  Specify either blocking or nonblocking when calling RTIOsapiSetSockOpt()
  with RTI_OSAPI_SOCKET_OPTION_BLOCK option.
  
  @see RTIOsapiSocket_setOption
*/
typedef enum {
    /** If RTIOsapiSocket_setOption(RTI_OSAPI_SOCKET_OPTION_BLOCK)
	operation failed, the errno will be set to this. */
    RTI_OSAPI_SOCKET_BLOCKING_ERROR = -1,
    /** Read operation will come back right away. */
    RTI_OSAPI_SOCKET_NONBLOCKING    = 0,
    /** Block on the socket until data is received. */
    RTI_OSAPI_SOCKET_BLOCKING       = 1
} RTIOsapiSocketBlockingType;

typedef enum {
    /** Use the default socket state. */
    RTI_OSAPI_SOCKET_OPTION_DEFAULT      = 0x0,
    /** Allow multiple sockets to bind to the same port.
       @see RTIOsapiSocket_bind */
    RTI_OSAPI_SOCKET_OPTION_REUSEPORT           = 0x1,
    /** Specify the size of the send buffer for the socket. Both the default
        and the maximum are OS dependent. */
    RTI_OSAPI_SOCKET_OPTION_SENDBUF             = 0x2,
    /** Specify the size of the recv buffer for the socket. Both the default
        and the maximum are OS dependent.  */
    RTI_OSAPI_SOCKET_OPTION_RECVBUF             = 0x4,
    /** Leave a multicast group.  As far as we know, this is not necessary
        if you are going to destroy the socket, coz OS automatically takes
	care of it. */
    RTI_OSAPI_SOCKET_OPTION_DROP_MEMBERSHIP     = 0x8,

    /** Join a multicast group.  Make sure you don't join a reserved
	multicast address! */
    RTI_OSAPI_SOCKET_OPTION_ADD_MEMBERSHIP      = 0x10,
    /** Specify the maximum number of hops for the multicast packets out of
	this socket.
	@see intTTL */
    RTI_OSAPI_SOCKET_OPTION_MULTICAST_TTL       = 0x20,
    /** Specify the outgoing interfaces for the multicast packets out of this
	socket.  By default, packets go out on the "primary" interface,
	whatever that may be. */
    RTI_OSAPI_SOCKET_OPTION_MULTICAST_IF        = 0x40,
    /** Turn on/off the loopback capability of the stack for multicast packets
	out of this socket.  By default, the stack copies the multicast
	packets to loopback interface if there is an application on the local
	node that wants to receive data for that multicast address and port.
	Turning the loopback off can spare the stack from doing a lot of work,
	but you must be certain that the application does not need to receive
	that data, because the data may not even be received on the interface,
	depending on the OS. Not all OSes support this option. */
    RTI_OSAPI_SOCKET_OPTION_MULTICAST_LOOPBACK  = 0x80,
    /** Turn on/off the blocking mode of this socket. */
    RTI_OSAPI_SOCKET_OPTION_BLOCK               = 0x100,
    /** Turn off the use of collision-avoidance algorithm. */
    RTI_OSAPI_SOCKET_OPTION_TCP_NODELAY	  = 0x200,
    /** Enable/disable the broadcasting from a dgram socket. */
    RTI_OSAPI_SOCKET_OPTION_BROADCAST 	  = 0x400,
    /** Enables linger on close if data is present */
    RTI_OSAPI_SOCKET_OPTION_LINGER        = 0x800,
    
    /** Set IPv4 TOS field or IPv6 Traffic Class field. */
    RTI_OSAPI_SOCKET_OPTION_PRIORITY     = 0x1000,
    /** Force IPv6 socket to be V6-only (req'd on Linux) */
    RTI_OSAPI_SOCKET_OPTION_V6ONLY       = 0x2000,
    /** The UDP checksum is turned on by default. In some platforms such as
     * Linux and Windows it can be turned off by setting the no checksum option
     * to 1. */
    RTI_OSAPI_SOCKET_OPTION_UDP_NOCHECKSUM     = 0x4000,
    /* Forces the exclusive use of a port in Windows so other sockets cannot be 
     * forcibly bound to the same address and port.  */        
    RTI_OSAPI_SOCKET_OPTION_EXCLUSIVEADDRUSE     = 0x8000
} RTIOsapiSocketOption;


  #if (defined(RTI_UNIX) || defined(RTI_VXWORKS))
    #define RTIOsapiSocketMulticastLoopbackFlag u_char
    #define RTIOsapiSocketBroadcastFlag int
    typedef unsigned char RTIOsapiSocketTTL;
  #elif defined(RTI_PSOS)
    typedef unsigned char RTIOsapiSocketTTL;
    typedef unsigned char RTIOsapiSocketMulticastLoopbackFlag;
    #define RTIOsapiSocketBroadcastFlag int
  #elif defined(RTI_NETOS)
    typedef unsigned char RTIOsapiSocketTTL;
    typedef u_char RTIOsapiSocketMulticastLoopbackFlag;
    typedef int RTIOsapiSocketBroadcastFlag;
  #elif defined(RTI_LYNX)
    typedef unsigned char RTIOsapiSocketTTL;
    typedef u_char RTIOsapiSocketMulticastLoopbackFlag;
    typedef int RTIOsapiSocketBroadcastFlag;
  #elif defined(RTI_QNX)
    typedef unsigned char RTIOsapiSocketTTL;
    typedef u_char RTIOsapiSocketMulticastLoopbackFlag;
    typedef int RTIOsapiSocketBroadcastFlag;
  #elif defined(RTI_INTY)
    typedef unsigned char RTIOsapiSocketTTL;
    typedef u_char RTIOsapiSocketMulticastLoopbackFlag;
    typedef int RTIOsapiSocketBroadcastFlag;
  #elif defined(RTI_OPENVMS)
    typedef unsigned char RTIOsapiSocketTTL;
    typedef u_char RTIOsapiSocketMulticastLoopbackFlag;
    typedef int RTIOsapiSocketBroadcastFlag;
  #elif defined(RTI_WIN32) || defined(RTI_WINCE)
    #define RTIOsapiSocketTTL int
    #define RTIOsapiSocketMulticastLoopbackFlag BOOL
    #define RTIOsapiSocketBroadcastFlag BOOL
  #else
    #error "Need to port"
  #endif

  #if defined(RTI_WIN32) || defined(RTI_WINCE)
    #define RTIOsapiSocket_close closesocket
/*e \ingroup RTIOsapiSocketClass
  
  Get the last error code set.  To make sure you are not reading an
  error code corresponding to a previous call, set the error code to
  RTI_OSAPI_SOCKET_NOERROR because making a netio call. This call is not
  thread-safe on some OSes at the moment.  
  
  @see RtiNetioErrnoSet RTI_OSAPI_SOCKET_NOERROR 
*/

    #define RTIOsapiSocket_getError WSAGetLastError
/*e \ingroup RTIOsapiSocketClass
  
  Set the system level error code.
  
  @param ErrorNumber Error code.
  
  @see RtiNetioErrnoGet
*/
    #define RTIOsapiSocket_setError WSASetLastError

    #define RTI_OSAPI_SOCKET_MULTICAST_LOOPBACK_ON  TRUE
    #define RTI_OSAPI_SOCKET_MULTICAST_LOOPBACK_OFF FALSE
    #define RTI_OSAPI_SOCKET_BROADCAST_ON  TRUE
    #define RTI_OSAPI_SOCKET_BROADCAST_OFF FALSE
  #else
    #ifdef RTI_VXWORKS
      #ifndef errno
        #define errno errnoGet()
      #endif
    #endif
    #define RTIOsapiSocket_close close
    #define RTIOsapiSocket_getError() errno
    #define RTIOsapiSocket_setError(x) errno = (x)
    #define RTI_OSAPI_SOCKET_BROADCAST_ON  1
    #define RTI_OSAPI_SOCKET_BROADCAST_OFF 0
    #define RTI_OSAPI_SOCKET_MULTICAST_LOOPBACK_ON  1
    #define RTI_OSAPI_SOCKET_MULTICAST_LOOPBACK_OFF 0
  #endif

extern RTIOsapiDllExport
/*e \ingroup RTIOsapiSocketClass

  Behave like UNIX ioctl() on a socket.

  Hides WinSock ioctlsocket() and presents the same interface as UNIXs ioctl().
  Always returns -1 on OS's that do not have a call equivalent
  to a UNIX ioctl (e.g. NetOS).

  @param sd      A operating system socket.
  @param request The option to set.
  @param total   Data associated with the request type

  @return Returns int just like ioctl() and ioctlsocket().  Please note that
  the return code is OS-specific.  Returns -1 when the underlying OS
  has no UNIX-like ioctl.
*/
int RTIOsapiSocket_ioctl(int sd, int request, int *total);

extern RTIOsapiDllExport
/*e \ingroup RTIOsapiSocketClass
   Set socket/file descriptor to non-blocking.

   Use notBlocking = 0 for Blocking notBlocking = 1 for Non-Blocking

   @param df Operating system socket.
   @param Blocking To set socket to either blocking or non-blocking.

   @see RTIOsapiSocketBlockingType
 */
int RTIOsapiSocket_setBlocking(int fd,
                              RTIOsapiSocketBlockingType Blocking);

extern RTIOsapiDllExport
/*e  \ingroup RTIOsapiSocketClass
  OS independent function to get socket option.

  @param s         Socket
  @param optType   Desired action.
  @param optVal    Pointer to the desired value corresponding to the optType.
  @param optLenPtr Pointer to the integer to return the actual value. Don't
                   set the initial value to 0!

  @return 0 if successful, -1 if error

  @see RTIOsapiSocketOption RTIOsapiSocket_setOption
*/
int RTIOsapiSocket_getOption(int s,
			     RTIOsapiSocketOption optType,
			     char *optVal, unsigned int *optLenPtr);

extern RTIOsapiDllExport
/*i  \ingroup RTIOsapiSocketClass
  OS independent function to setsocket option.

  @param s       Socket
  @param optType Desired action.
  @param optVal  Pointer to the desired value corresponding to the optType.
  @param optLen  Length of the optVal in bytes.

  @return 0 if successful, -1 if error

  @see RTIOsapiSocket_getOption
*/
int RTIOsapiSocket_setOption(int s,
			     RTIOsapiSocketOption optType,
			     const char *optVal, unsigned int optLen);

extern RTIOsapiDllExport
/*e \ingroup RTIOsapiSocketClass

  @brief Receive data from a socket.
  
  Returns -1 on failure; otherwise, returns number of bytes received.
*/
int RTIOsapiSocket_recvFrom(int sd, void *buffer, size_t bufferSize,
                            struct sockaddr *fromAddress, socklen_t *addressLen);

extern RTIOsapiDllExport
/*i  \ingroup RTIOsapiSocketClass
  OS independent function to setsocket option.

  @param s       Socket
  @param optType Desired action.
  @param optVal  Pointer to the desired value corresponding to the optType.
  @param optLen  Length of the optVal in bytes.
  @param family  RTI_OSAPI_SOCKET_AF_INET or RTI_OSAPI_SOCKET_AF_INET6.

  @return 0 if successful, -1 if error

  @see RTIOsapiSocket_getOption
*/
int RTIOsapiSocket46_setOption(
        int s,
        RTIOsapiSocketOption optType,
        const char *optVal,
        unsigned int optLen,
        RTIOsapiSocketAFKind family);

extern RTIOsapiDllExport
/*i  \ingroup RTIOsapiSocketClass
  OS independent function to create a socket for UDPv4, TCPv4, UDPv6, TCPv6 

  @param socketType     
  @return the socket

  @see 
*/
int RTIOsapiSocket_create(RTIOsapiSocketType socketType);

extern RTIOsapiDllExport
/*e \ingroup RTIOsapiSocketClass

  @brief Send single buffer of data to a socket.
  
  Returns the number of bytes successfully sent.
*/
int RTIOsapiSocket_sendTo(int sd, const void *buffer, size_t bufferSize,
                          const struct sockaddr *address, socklen_t addressLen);

extern RTIOsapiDllExport
/*i \ingroup NDDS_OsapiSocketComponent
  @brief Ignore unreachable ICMP destinations messages

  Sockets that are used to send and receive concurrently (e.g. for STUN
  in WAN transport) require this functionality. Otherwise, the receive
  thread will unblock with the error WSAECONNRESET every time a send
  operation on the same socket cannot reach its final detination.

  see http://support.microsoft.com/kb/263823

  @param socket  Socket

  @return 0 on success or -1 if there is an error.
*/
int RTIOsapiSocket_ignore_port_unreachable_on_receive(int socket);

extern RTIOsapiDllExport
/*e \ingroup RTIOsapiSocketClass

  @brief Assign a port number to a socket.

  Bind a port to a socket.  Fills in sockAddr.  If the passed port number is
  0, then the system will assign a new port number.  If the passed port number
  is in use, RTIOsapiSocket_bind returns -1.  If the bind succeeds, the bound port
  number is returned, and is also available as ntohs(sockAddr->sin_port).
  This is only necessary if the socket will receive data. 
*/
int RTIOsapiSocket_bind(int sd, struct sockaddr_in *sockAddr,
			int portnum);

extern RTIOsapiDllExport
int RTIOsapiSocket_bindWithIP(int sd, struct sockaddr_in *sockAddr, unsigned int ip, 
                              int portnum);

extern RTIOsapiDllExport
int RTIOsapiSocket_getHostByName(
    struct in_addr * address_out,
    const char * hostName_in);


#ifdef __cplusplus
    }	/* extern "C" */
#endif

#endif /* osapi_socket_h */
