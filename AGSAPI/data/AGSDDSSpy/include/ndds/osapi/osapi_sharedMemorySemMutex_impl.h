/* (c) Copyright 2003-2015, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)osapi_sharedMemorySemMutex_impl.h    generated by: makeheader    Fri Feb 16 13:51:08 2018
 *
 *		built from:	sharedMemorySemMutex_impl.ifc
 */

#ifndef osapi_sharedMemorySemMutex_impl_h
#define osapi_sharedMemorySemMutex_impl_h


#ifdef __cplusplus
    extern "C" {
#endif


struct RTIOsapiSharedMemorySemMutexHandleImpl {
    /*i handle to the shared memory.
      Used as a reference when delete the shared memory
    */
    RTIOsapiSharedMemoryNativeHandle_SemMutex _nativeHandle;

    /*i Copy of the key used to retrieve this mutex.
     * Some architectures requires it when the resource is deleted.
     */
    int _key;

    /*i The type of semaphore: SEMMUTEX_TYPE_SEMAPHORE...
	This value is used to check the precondition of each SemMutex
	function, to make sure we don't mix and match create/attach of
	semaphore of one type and perform operation with another type.
        This value is used ONLY when RTI_PRECONDITION_TEST is defined.
     */
    int _semType;

    /*i This counter is used by the MUTEX type only to keep track of how
	many locks() has been performed.
        Probably this field should stay only in the MUTEX definition...
     */
    int _lockCount;

    /*i This value is used by the MUTEX type only to store the PID of the 
        thread/process that performed the MUTEX Lock. This is to ensure
        that a thread sharing the same mutex handle doesn't call the _unlock
        if is not the owner of the mutex.
        Probably this field should stay only in the MUTEX definition...
     */
    RTI_UINT32 _lockPid;
};


struct RTIOsapiSharedMemorySemMutexHandle {
    union {
	struct RTIOsapiSharedMemorySemMutexHandleImpl handle;
	int pad[4];
    } impl;
};



/*i The following constants MUST start from 0 since they are used
    to reference arrays
 */
#define SEMMUTEX_TYPE_SEMAPHORE		0
#define SEMMUTEX_TYPE_BINARYSEM		1
#define SEMMUTEX_TYPE_MUTEX		2


extern RTIOsapiDllExport
RTIBool RTIOsapiSharedMemorySemMutex_create(
		struct RTIOsapiSharedMemorySemMutexHandle *handle, 
		int * statusOut,
		int key,
		int type);

extern RTIOsapiDllExport
RTIBool RTIOsapiSharedMemorySemMutex_attach(
		struct RTIOsapiSharedMemorySemMutexHandle *handle, 
		int *statusOut,
		int key,
		int type);

extern RTIOsapiDllExport
RTIBool RTIOsapiSharedMemorySemMutex_createOrAttach(
		struct RTIOsapiSharedMemorySemMutexHandle *handle, 
		int *statusOut,
		int key,
		int type);

extern RTIOsapiDllExport
RTIBool RTIOsapiSharedMemorySemMutex_give(
		struct RTIOsapiSharedMemorySemMutexHandle *handle,
		int* failReasonOut,
		int type);

extern RTIOsapiDllExport
RTIBool RTIOsapiSharedMemorySemMutex_take(
		struct RTIOsapiSharedMemorySemMutexHandle *handle,
		int* failReasonOut,
		int type);

extern RTIOsapiDllExport
RTIBool RTIOsapiSharedMemorySemMutex_detach(
		struct RTIOsapiSharedMemorySemMutexHandle *handle,
		int type);

extern RTIOsapiDllExport
RTIBool RTIOsapiSharedMemorySemMutex_delete(
		struct RTIOsapiSharedMemorySemMutexHandle *handle,
		int type);


#ifdef __cplusplus
    }	/* extern "C" */
#endif

#endif /* osapi_sharedMemorySemMutex_impl_h */
