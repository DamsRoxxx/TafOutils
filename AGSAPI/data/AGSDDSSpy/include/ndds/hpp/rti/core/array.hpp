/* $Id$
 (c) Copyright, Real-Time Innovations, 2014-2016.
 All rights reserved.

 No duplications, whole or partial, manual or electronic, may be made
 without express written permission.  Any such copies, or
 revisions thereof, must display this notice unaltered.
 This code contains trade secrets of Real-Time Innovations, Inc.

modification history
--------------------
1.1,22jul14,acr CODEGENII-330 fill_array now works for an arbitrary number of
                dimensions
1.0,21may14,ajm CODEGENII-173 CPPPSM-205 Modifying initialize_native_array
                to receive CType
1.0,18feb13,acr Created
============================================================================= */

#ifndef RTI_DDS_CORE_ARRAY_HPP_
#define RTI_DDS_CORE_ARRAY_HPP_

// IMPORTANT: macros.hpp must be the first RTI header included in every header
// file so that symbols are exported correctly on Windows
#include <dds/core/macros.hpp>

#include "dds_c/dds_c_infrastructure.h"

#include <dds/core/array.hpp>
#include <rti/core/corefwd.hpp>

namespace rti { namespace core {


// The following utility methods are used by code generated by rtiddsgen

/**
 * Initializes all the elements of an array to a value
 */
template <typename T, size_t N>
void fill_array(dds::core::array<T, N>& array, const T& value)
{
    std::fill_n(array.begin(), array.size(), value);
}

/**
 * Initializes all the elements of an array of arbitrary dimensions
 */
template <typename FinalType, typename ArrayType, size_t N, size_t M>
void fill_array(
    dds::core::array<dds::core::array<ArrayType, N>, M>& multi_array,
    const FinalType& value)
{
    typedef typename dds::core::array<dds::core::array<ArrayType, N>, M>::iterator iterator;

    for (iterator it = multi_array.begin(); it != multi_array.end(); ++it) {
        fill_array(*it, value);
    }
}

/**
 * Initializes all the elements of an array using a C function
 */
template <typename CType, typename T, size_t N, typename InitFunc>
void initialize_native_array(
    dds::core::array<T, N>& array, InitFunc init_func)
{
    typedef typename dds::core::array<T, N>::iterator iterator;

    for (iterator it = array.begin(); it != array.end(); ++it) {
        if (!init_func(reinterpret_cast<CType*>(&(*it)))) {
            throw std::bad_alloc();
        }
    }
}

} } // namespace rti::core

#endif // RTI_DDS_CORE_ARRAY_HPP_
