/* (c) Copyright 2003-2015, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)reda_cursor_impl.h    generated by: makeheader    Fri Feb 16 13:51:16 2018
 *
 *		built from:	cursor_impl.ifc
 */

#ifndef reda_cursor_impl_h
#define reda_cursor_impl_h


#include "reda/reda_inlineList.h"
#include "reda/reda_hashedSkiplist.h"

#ifdef __cplusplus
    extern "C" {
#endif


typedef int REDACursorState;

 
struct REDACursor {
    /*i The table keeps a list of all the bound cursors */
    struct REDAInlineListNode node;

    /* ============= START PART MANAGED BY REDATableEpoch =============== */
    /*i Never use these directly; only access them through the
        functionality of the TableEpoch module; I gave it a name
	starting with _te_ (TableEpoch) to make sure nobody is
	tempted to do this... */
    struct REDATable *_te_table;
    RTIBool           _te_tableIsRemoved;
    RTIBool           _te_tableIsDeleted;
    REDAEpoch         _te_tableEpoch;
    /* =============== END PART MANAGED BY REDATableEpoch =============== */

    /*i See the state diagram for possible transitions */
    REDACursorState _state;

    /*i The worker to which the cursor is bound. */
    struct REDAWorker *_worker;

    /*i Points to the current record */
    const struct REDASkiplistNode *_current;

    /*i This is a auxiliary node pointer used for safely iterating through a
     *  table. See REDACursor_gotoNextMacro. */
    const struct REDASkiplistNode *_tmpCurrent;

    /* ============= START PART MANAGED BY REDAModificationEpoch =============== */
    /*i Never use these directly; only access them through the
        functionality of the ModifcationEpoch module */
    REDAEpoch _me_modificationEpoch;
    /* =============== END PART MANAGED BY REDATableEpoch =============== */
    
    /* The adminEA of the table to which the Cursor is bound */
    struct REDAExclusiveArea *_tableAdminEA;
};

extern REDADllExport RTIBool
REDATableEpoch_startCursor(struct REDACursor *cursor, int *failReasonPtr);



#define REDA_CURSOR_STATE_BOUND_BIT         0x01
#define REDA_CURSOR_STATE_ACTIVE_BIT        0x02
#define REDA_CURSOR_STATE_POSITIONED_BIT    0x04
#define REDA_CURSOR_STATE_TABLE_LOCKED_BIT  0x08
#define REDA_CURSOR_STATE_RECORD_LOCKED_BIT 0x10

#define REDA_CURSOR_STATE_UNBOUND           0

#define REDA_CURSOR_STATE_INACTIVE (REDA_CURSOR_STATE_BOUND_BIT)

#define REDA_CURSOR_STATE_LOCKLESS \
    (REDA_CURSOR_STATE_BOUND_BIT | REDA_CURSOR_STATE_ACTIVE_BIT)

#define REDA_CURSOR_STATE_TABLE_LOCKED \
    (REDA_CURSOR_STATE_LOCKLESS | REDA_CURSOR_STATE_TABLE_LOCKED_BIT)

#define REDA_CURSOR_STATE_TABLE_AND_RECORD_LOCKED \
    (REDA_CURSOR_STATE_BOUND_BIT                | \
     REDA_CURSOR_STATE_ACTIVE_BIT               | \
     REDA_CURSOR_STATE_POSITIONED_BIT           | \
     REDA_CURSOR_STATE_TABLE_LOCKED_BIT         | \
     REDA_CURSOR_STATE_RECORD_LOCKED_BIT)

#define REDACursor_isInactive(cursor) \
    ( ((cursor)!=NULL) && \
      !(((cursor)->_state) & REDA_CURSOR_STATE_ACTIVE_BIT) )

#define REDACursor_isActive(cursor) \
    ( ((cursor)!=NULL) && \
      (((cursor)->_state) & REDA_CURSOR_STATE_ACTIVE_BIT) )

#define REDACursor_isActiveAndRepositionable(cursor) \
    ( ((cursor)!=NULL) && \
      (((cursor)->_state) & REDA_CURSOR_STATE_ACTIVE_BIT) && \
      !(((cursor)->_state) & REDA_CURSOR_STATE_RECORD_LOCKED_BIT) )

#define REDACursor_isAtTopOrPositionedAndRepositionable(cursor) \
    ( ((cursor)!=NULL) && \
      (((cursor)->_state) & REDA_CURSOR_STATE_ACTIVE_BIT) && \
      (((cursor)->_current) != NULL) && \
      !(((cursor)->_state) & REDA_CURSOR_STATE_RECORD_LOCKED_BIT) )

#define REDACursor_isPositioned(cursor) \
    ( (cursor!=NULL) && \
      ((cursor->_state) & REDA_CURSOR_STATE_POSITIONED_BIT) )

#define REDACursor_isPositionedAndTableLocked(cursor) \
    ( (cursor!=NULL) && \
      ((cursor->_state) & REDA_CURSOR_STATE_POSITIONED_BIT) && \
      ((cursor->_state) & REDA_CURSOR_STATE_TABLE_LOCKED_BIT) )

#define REDACursor_isRecordLocked(cursor) \
    ( (cursor!=NULL) && \
      ((cursor->_state) & REDA_CURSOR_STATE_RECORD_LOCKED_BIT) )

#define REDACursor_isTableLocked(cursor) \
    ( (cursor!=NULL) && \
      ((cursor->_state) & REDA_CURSOR_STATE_TABLE_LOCKED_BIT) )

#define REDACursor_stateEqualsTableLocked(cursor) \
    ( ((cursor)!=NULL) && \
      ((cursor)->_state & REDA_CURSOR_STATE_TABLE_LOCKED_BIT) && \
      !((cursor)->_state & REDA_CURSOR_STATE_RECORD_LOCKED_BIT) )

/* ----------------------------------------------------------------- */
/*i \ingroup REDATableEpoch
   Get the table the cursor is bound to BUT this can only be
   called AFTER the cursor has succesfully started; this method
   does not enforce this but the name should help verify correct
   usage
*/
#define REDATableEpoch_getTableFromStartedCursor(cursor) \
    ((cursor)->_te_table)

/* GPC: Implementation should be re-factored to make REDACursor_start
   symmetric with REDACursor_finish and to separate concerns better
   between REDACursor_xxx and REDATableEpoch_xxx
   For example, make REDACursor_start always a function. Make
   REDATableEpoch::startCursor a macro. Have the cursor state change
   on the REDACursor::start, not on the REDATableEpoch::startCursor
*/
/* ----------------------------------------------------------------- */
#define REDACursor_startMacro(cursor, failReasonPtr) \
  ( REDATableEpoch_startCursor(cursor, failReasonPtr) ? \
    ((cursor)->_state = REDA_CURSOR_STATE_LOCKLESS, RTI_TRUE) : \
    RTI_FALSE )
#ifdef RTI_PRECONDITION_TEST
  #define REDACursor_start REDACursor_startFnc
#else
  #define REDACursor_start REDACursor_startMacro
#endif

/* ----------------------------------------------------------------- */
#define REDACursor_gotoTopMacro(cursor) \
    REDAHashedSkiplist_gotoTopNodeMacro( \
	REDATableEpoch_getTableFromStartedCursor(cursor)->_list, \
	&((cursor)->_current) ); \
    (cursor)->_state &= ~REDA_CURSOR_STATE_POSITIONED_BIT; 
#ifdef RTI_PRECONDITION_TEST
  #define REDACursor_gotoTop REDACursor_gotoTopFnc
#else
  #define REDACursor_gotoTop REDACursor_gotoTopMacro
#endif

/* ----------------------------------------------------------------- */
/* CORE-6928: We use _tmpCurrent to save a copy of the pointer to the current
 * node. This copy is used by gotoNextNodeSafeMacro to ensure it will be able
 * to iterate to the next bucket even if this macro is executed at the same time
 * we are removing the next node in the list. */
#define REDACursor_gotoNextMacro(cursor) \
  ( ( (cursor)->_tmpCurrent = (cursor)->_current, \
      REDAHashedSkiplist_gotoNextNodeSafeMacro( \
        (REDATableEpoch_getTableFromStartedCursor(cursor))->_list, \
        &((cursor)->_current), &((cursor)->_tmpCurrent) )) ? \
    ( (cursor)->_state |=  REDA_CURSOR_STATE_POSITIONED_BIT, RTI_TRUE ) : \
    ( (cursor)->_state &= ~REDA_CURSOR_STATE_POSITIONED_BIT, RTI_FALSE ) )
#ifdef RTI_PRECONDITION_TEST
  #define REDACursor_gotoNext REDACursor_gotoNextFnc
#else
  #define REDACursor_gotoNext REDACursor_gotoNextMacro
#endif

/* ----------------------------------------------------------------- */
#define REDACursor_getKeyMacro(cursor) \
  (REDATable_getKeyFromNodeMacro( \
     REDATableEpoch_getTableFromStartedCursor(cursor), \
     (cursor)->_current))
#ifdef RTI_PRECONDITION_TEST
  #define REDACursor_getKey REDACursor_getKeyFnc
#else
  #define REDACursor_getKey REDACursor_getKeyMacro
#endif

/* ----------------------------------------------------------------- */
#define REDACursor_getReadOnlyAreaMacro(cursor) \
  (REDATable_getReadOnlyAreaFromNodeMacro( \
     REDATableEpoch_getTableFromStartedCursor(cursor), \
     (cursor)->_current))
#ifdef RTI_PRECONDITION_TEST
  #define REDACursor_getReadOnlyArea REDACursor_getReadOnlyAreaFnc
#else
  #define REDACursor_getReadOnlyArea REDACursor_getReadOnlyAreaMacro
#endif

/* ----------------------------------------------------------------- */
#define REDACursor_getRecordEAMacro(cursor) \
   ((REDATable_getAdminAreaFromNodeMacro( \
     REDATableEpoch_getTableFromStartedCursor(cursor), \
     (cursor)->_current))->_recordEA)
#ifdef RTI_PRECONDITION_TEST
  #define REDACursor_getRecordEA REDACursor_getRecordEAFnc
#else
  #define REDACursor_getRecordEA REDACursor_getRecordEAMacro
#endif

/* ----------------------------------------------------------------- */
#define REDACursor_getTableUserDataMacro(cursor) \
   (REDATable_getTableUserDataMacro( \
     REDATableEpoch_getTableFromStartedCursor(cursor)))
#ifdef RTI_PRECONDITION_TEST
  #define REDACursor_getTableUserData REDACursor_getTableUserDataFnc
#else
  #define REDACursor_getTableUserData REDACursor_getTableUserDataMacro
#endif

/* ----------------------------------------------------------------- */
#define REDACursor_getTableRecordCountMacro(cursor) \
   (REDATable_getRecordCountMacro( \
     REDATableEpoch_getTableFromStartedCursor(cursor)))
#ifdef RTI_PRECONDITION_TEST
  #define REDACursor_getTableRecordCount REDACursor_getTableRecordCountFnc
#else
  #define REDACursor_getTableRecordCount REDACursor_getTableRecordCountMacro
#endif

/* ----------------------------------------------------------------- */
#define REDACursor_getTableEAMacro(cursor) \
   (REDATable_getTableEAMacro( \
     REDATableEpoch_getTableFromStartedCursor(cursor)))
#ifdef RTI_PRECONDITION_TEST
  #define REDACursor_getTableEA REDACursor_getTableEAFnc
#else
  #define REDACursor_getTableEA REDACursor_getTableEAMacro
#endif

/* ----------------------------------------------------------------- */
#define REDACursor_startSafeFnc(cursor, failReasonPtr, cursors, currentIndex) \
  (                                                         \
      REDACursor_startFnc(cursor, failReasonPtr) ?          \
      ((cursors)[(*(currentIndex))++] = (cursor)) :         \
      NULL                                                  \
  )
#define REDACursor_startSafeMacro(cursor, failReasonPtr, cursors, currentIndex)\
  (                                                         \
      REDACursor_startMacro(cursor, failReasonPtr) ?        \
      ((cursors)[(*(currentIndex))++] = (cursor)) :         \
      NULL                                                  \
  )
#ifdef RTI_PRECONDITION_TEST
  #define REDACursor_startSafe REDACursor_startSafeFnc
#else
  #define REDACursor_startSafe REDACursor_startSafeMacro
#endif

/* ----------------------------------------------------------------- */
#define REDACursor_finishSafe(cursors, currentIndex)     \
    for (; *(currentIndex)>0; --(*(currentIndex))) {     \
        REDACursor_finish((cursors)[*(currentIndex)-1]); \
        (cursors)[*(currentIndex)-1] = NULL;             \
    }                                                    \

/* ----------------------------------------------------------------- */
#define REDACursor_tableHasReadOnlyAreaMacro(cursor) \
   (REDATable_tableHasReadOnlyAreaMacro( \
     REDATableEpoch_getTableFromStartedCursor(cursor)))
#ifdef RTI_PRECONDITION_TEST
  #define REDACursor_tableHasReadOnlyArea REDACursor_tableHasReadOnlyAreaFnc
#else
  #define REDACursor_tableHasReadOnlyArea REDACursor_tableHasReadOnlyAreaMacro
#endif

/* ----------------------------------------------------------------- */
#define REDACursor_tableHasReadWriteAreaMacro(cursor) \
   (REDATable_tableHasReadWriteAreaMacro( \
     REDATableEpoch_getTableFromStartedCursor(cursor)))
#ifdef RTI_PRECONDITION_TEST
  #define REDACursor_tableHasReadWriteArea REDACursor_tableHasReadWriteAreaFnc
#else
  #define REDACursor_tableHasReadWriteArea REDACursor_tableHasReadWriteAreaMacro
#endif

/* ----------------------------------------------------------------- */
#define REDACursor_getReadWriteAreaSizeMacro(cursor) \
   (REDATable_getReadWriteAreaSizeMacro( \
     REDATableEpoch_getTableFromStartedCursor(cursor)))
#ifdef RTI_PRECONDITION_TEST
  #define REDACursor_getReadWriteAreaSize REDACursor_getReadWriteAreaSizeFnc
#else
  #define REDACursor_getReadWriteAreaSize REDACursor_getReadWriteAreaSizeMacro
#endif

/* ----------------------------------------------------------------- */
#define REDACursor_unfreezeReadWriteAreaMacro(cursor) \
  (REDATable_unfreezeReadWriteAreaMacro(              \
    REDATableEpoch_getTableFromStartedCursor(cursor), \
    (cursor)->_current, (cursor)))
#ifdef RTI_PRECONDITION_TEST
  #define REDACursor_unfreezeReadWriteArea REDACursor_unfreezeReadWriteAreaFnc
#else
  #define REDACursor_unfreezeReadWriteArea REDACursor_unfreezeReadWriteAreaMacro
#endif



#ifdef __cplusplus
    }	/* extern "C" */
#endif

#endif /* reda_cursor_impl_h */
