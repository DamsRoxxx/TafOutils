/* (c) Copyright 2003-2015, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)reda_database.h    generated by: makeheader    Fri Feb 16 13:51:18 2018
 *
 *		built from:	database.ifc
 */

#ifndef reda_database_h
#define reda_database_h



  #ifndef osapi_type_h
    #include "osapi/osapi_type.h"
  #endif
  #ifndef reda_worker_h
    #include "reda/reda_worker.h"
  #endif
  #ifndef reda_fastBuffer_h
    #include "reda/reda_fastBuffer.h"
  #endif
  #ifndef reda_orderedDataType_h
    #include "reda/reda_orderedDataType.h"
  #endif
  #ifndef reda_table_h
    #include "reda/reda_table.h"
  #endif

#ifdef __cplusplus
    extern "C" {
#endif

struct REDADatabase;

struct REDACursorPerWorker;

struct REDAWeakReference;

struct REDACursor;

struct REDADatabaseProperty {
    /*e hint for memory management of table: resources are allocated
      in chunks that have enough space to store tableAllocationChunk
      tables */
    struct REDAFastBufferPoolGrowthProperty growth;
    
    /*e maximum skiplist level for all tables in the database */
    char skiplistLevelMax;
    
    /*e initial number of total records across all tables 
      for which resources are allocated at the database level;
      the resources will grow as needed by doubling */
    int totalRecordCountInitial;
    
    /*e Initial number of weak references.
 
      Each database has a collection of weak references to records of the
      tables it contains. This paramater specifies the initial size of the
      collection. The actual initial value used may be larger than the one
      specified here if the specified initial value would not allow the
      number of weak references to grow to the specified maximum. */
    int weakReferenceCountInitial;
    
    /*e Maximum number of weak references.
 
      Each database has a collection of weak references to records of the
      tables it contains. This paramater specifies the maximum size of the
      collection. The special constant REDA_TABLE_WEAKREF_UNLIMITED can be
      used to indicate that the collection should grow indefinitely as
      needed. */
    int weakReferenceCountMax;
};


#define REDA_DATABASE_SKIPLIST_LEVEL_MAX (7)


#define REDA_DATABASE_TOTAL_RECORD_COUNT_INITIAL (128)


#define REDA_DATABASE_WEAKREF_INITIAL (1)


#define REDA_DATABASE_PROPERTY_DEFAULT {       \
    REDA_FAST_BUFFER_POOL_GROWTH_PROPERTY_DEFAULT, \
    REDA_DATABASE_SKIPLIST_LEVEL_MAX,          \
    REDA_DATABASE_TOTAL_RECORD_COUNT_INITIAL,  \
    REDA_DATABASE_WEAKREF_INITIAL,             \
    REDA_TABLE_WEAKREF_UNLIMITED }

extern REDADllExport 
struct REDADatabase *
REDADatabase_new(struct REDAWorkerFactory *workerFactory,
		 struct REDAExclusiveArea *adminEA,
		 const struct REDADatabaseProperty *property,
		 struct REDAWorker *worker);

extern REDADllExport 
void
REDADatabase_getProperty(struct REDADatabase *me,
                         struct REDADatabaseProperty *property,
                         struct REDAWorker *worker);

extern REDADllExport 
struct REDAWorkerFactory *
REDADatabase_getWorkerFactory(struct REDADatabase *me);

extern REDADllExport
RTIBool
REDADatabase_delete(struct REDADatabase *me,
                    struct REDAWorker *worker);

extern REDADllExport
RTIBool
REDADatabase_cleanup(struct REDADatabase *me,
                     RTIBool *databaseCanBeDeleted,
                     struct REDAWorker *worker);

extern REDADllExport 
RTIBool
REDADatabase_createTable(struct REDADatabase *me, 
			 struct REDAWeakReference *tableReference,
			 const char *tableName,
			 struct REDAOrderedDataType *keyType,
			 struct REDAOrderedDataType *readOnlyAreaType,
			 struct REDAOrderedDataType *readWriteAreaType,
			 const struct REDAHashDefinition *hashDefinition,
			 struct REDAExclusiveArea *tableEA,
			 REDATableFinalizeFunction tableFinalizeFnc, 
			 void *tableFinalizeParam,
			 REDATableRecordFinalizeFunction recordFinalizeFnc,
			 void *recordFinalizeParam,
			 const struct REDAFastBufferPoolGrowthProperty* growthPropertyIn,
			 void *tableUserData,
			 struct REDAWorker *worker);

extern REDADllExport
RTIBool 
REDADatabase_bindCursor(struct REDADatabase *me,
			struct REDACursor *cursor,
			struct REDAWeakReference *tableReference,
			struct REDAWorker *worker);

extern REDADllExport
struct REDACursorPerWorker *
REDADatabase_createCursorPerWorker(
    struct REDADatabase *me,
    struct REDAWeakReference *tableReference);

extern REDADllExport
void
REDADatabase_destroyCursorPerWorker(
    struct REDADatabase *me,
    struct REDACursorPerWorker *cursorPerWorker,
    struct REDAWorker *worker);

extern REDADllExport
RTIBool 
REDACursorPerWorker_assertAndStartCursorFnc(struct REDACursorPerWorker *me, 
					 struct REDACursor **cursorPtr,
					 int* failReasonPtr,
					 struct REDAWorker *worker);

extern REDADllExport struct REDACursor *
REDACursorPerWorker_assertCursor(struct REDACursorPerWorker *me, 
				 struct REDACursor **cursorPtr,
				 struct REDAWorker *worker);

extern REDADllExport
RTIBool
REDADatabase_findTable(struct REDADatabase *me,
		       struct REDAWeakReference *tableReference,
		       const char *tableName,
		       struct REDAWorker *worker);

extern REDADllExport
RTIBool
REDADatabase_listTables(struct REDADatabase *me,
			struct REDAWorker *worker);

extern REDADllExport
struct REDAExclusiveArea *
REDADatabase_createExclusiveArea(struct REDADatabase *database,
				 int level, 
				 struct REDAWorker *worker);

extern REDADllExport
void
REDADatabase_destroyExclusiveArea(struct REDADatabase *database,
				  struct REDAExclusiveArea *ea,
				  struct REDAWorker *worker);

struct REDADatabaseInfo {
    /*e */
    void *databaseId;
    /*e */
    int tableCount;
    /*e */
    int maxListLevelForTables;
    /*e */
    struct REDAWorkerFactoryInfo *workerFactoryInfo;
    /*e */
    struct REDAWeakReferenceManagerInfo *weakReferenceManagerInfo;
    /*e */
    struct REDATableInfo *tableOfTablesInfo;
    /*e */
    struct REDAExclusiveAreaInfo *adminExclusiveAreaInfo;
};

extern REDADllExport struct REDADatabaseInfo *
REDADatabaseInfo_new(struct REDADatabase *database);

extern REDADllExport void
REDADatabaseInfo_delete(struct REDADatabaseInfo *me);

extern REDADllExport void
REDADatabaseInfo_print(struct REDADatabaseInfo *me, int indent, int verbosity);


#ifdef __cplusplus
    }	/* extern "C" */
#endif

  #include "reda/reda_database_impl.h"

#endif /* reda_database_h */
