/* (c) Copyright 2003-2015, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)connext_cpp_infrastructure.h    generated by: makeheader    Fri Feb 16 13:52:55 2018
 *
 *		built from:	infrastructure.ifcxx
 */

#ifndef connext_cpp_infrastructure_h
#define connext_cpp_infrastructure_h



#include <string>
#include <stdexcept>
#include <memory>

#include "ndds/ndds_namespace_cpp.h"

#include "dds_c/dds_c_infrastructure.h"
#include "dds_c/dds_c_log_impl.h"

#include "connext_cpp/connext_cpp_dll.h"
#include "connext_cpp/connext_cpp_exception.h"

namespace DDS {

void swap(DDS::KeyedString & ks1, 
          DDS::KeyedString & ks2);

void swap(DDS::KeyedOctets & ko1, 
          DDS::KeyedOctets & ko2);

} // namespace std

namespace connext {

using namespace DDS;

// Forward declaration
template <typename T>
class FastObjectPool;

template<typename T, bool> class SampleIterator;
template<typename T, bool> class ValidSampleIterator;
template<typename T>       class Sample;
template<typename T>       class WriteSample;
template<typename T>       class SampleRef;
template<typename T>       class WriteSampleRef;
template<class T>          class LoanedSamples;

template<>                 class SampleRef<std::string>;      // Invalid type
template<>                 class Sample<DDS::DynamicData>;    // Invalid type

/* Traits of DDS-compatible types */
template <typename T> 
struct dds_type_traits
{
    typedef typename T::Seq          Seq;
    typedef const typename T::Seq    ConstSeq;
    typedef SampleRef<T>             SampleRefType;
    typedef SampleRef<T>             SampleIteratorValueType;
    typedef SampleRef<const T>       ConstSampleIteratorValueType;
    typedef SampleIterator<T, false> iterator;
    typedef SampleIterator<T, true>  const_iterator;
    typedef typename T::TypeSupport  TypeSupport;
    typedef typename T::DataReader   DataReader;
    typedef typename T::DataWriter   DataWriter;
    typedef LoanedSamples<T>         LoanedSamplesType;
};

template <> 
struct dds_type_traits<char *> 
{
    typedef DDS_StringSeq                  Seq;
    typedef const DDS_StringSeq            ConstSeq;
    typedef SampleRef<char *>              SampleRefType;
    typedef SampleRef<char *>              SampleIteratorValueType;
    typedef SampleRef<const char *>        ConstSampleIteratorValueType;
    typedef SampleIterator<char *, false>  iterator;
    typedef SampleIterator<char *, true>   const_iterator;
    typedef DDSStringTypeSupport           TypeSupport;
    typedef DDSStringDataReader            DataReader;
    typedef DDSStringDataWriter            DataWriter; 
    typedef LoanedSamples<char *>          LoanedSamplesType;
};

template <> 
struct dds_type_traits<const char *> 
{
    typedef DDS_StringSeq                        Seq;
    typedef const DDS_StringSeq                  ConstSeq;
    typedef SampleRef<const char *>              SampleRefType;
    typedef SampleRef<const char *>              SampleIteratorValueType;
    typedef SampleRef<const char *>              ConstSampleIteratorValueType;
    typedef SampleIterator<const char *, false>  iterator;
    typedef SampleIterator<const char *, true>   const_iterator;
    typedef DDSStringTypeSupport                 TypeSupport;
    typedef DDSStringDataReader                  DataReader;
    typedef DDSStringDataWriter                  DataWriter; 
    typedef LoanedSamples<const char *>          LoanedSamplesType;
};

template <> 
struct dds_type_traits<DDS_KeyedString> 
{
    typedef DDS_KeyedStringSeq                      Seq;
    typedef const DDS_KeyedStringSeq                ConstSeq;
    typedef SampleRef<DDS_KeyedString>              SampleRefType;
    typedef SampleRef<DDS_KeyedString>              SampleIteratorValueType;
    typedef SampleRef<const DDS_KeyedString>        ConstSampleIteratorValueType;
    typedef SampleIterator<DDS_KeyedString, false>  iterator;
    typedef SampleIterator<DDS_KeyedString, true>   const_iterator;
    typedef DDSKeyedStringTypeSupport               TypeSupport;
    typedef DDSKeyedStringDataReader                DataReader;
    typedef DDSKeyedStringDataWriter                DataWriter; 
    typedef LoanedSamples<DDS_KeyedString>          LoanedSamplesType;
};

template <> 
struct dds_type_traits<std::string> 
     : dds_type_traits<const char *>
{
    typedef LoanedSamples<std::string> LoanedSamplesType;
};

template <> 
struct dds_type_traits<DDS_SampleInfo> 
{
    typedef SampleInfoSeq       Seq; 
    typedef const SampleInfoSeq ConstSeq;
};

namespace details {

// Compile-type assertion (fail when template parameter resolves as false)
template<bool> struct Write_Sample_Types_Must_Match_Assertion_Failure;
template<>     struct Write_Sample_Types_Must_Match_Assertion_Failure<true> {};

template<bool> struct Reply_Type_Must_Be_A_String_Type;
template<>     struct Reply_Type_Must_Be_A_String_Type<true> {};

template<bool> struct Request_Type_Must_Be_A_String_Type;
template<>     struct Request_Type_Must_Be_A_String_Type<true> {};


template <bool, typename T, typename U>
struct if_ {
    typedef T type;
};

template <typename T, typename U>
struct if_ <false, T, U> {
    typedef U type;
};

template <typename T, typename U>
struct is_same {
    enum { value = false }; 
};

template <typename T>
struct is_same<T, T> {
    enum { value = true }; 
};

template <typename T>
struct is_const {
    enum { value = false };
};

template <typename T>
struct is_const<const T> {
    enum { value = true };
};

template <typename T>
struct UsesStringDataReader 
{
    enum { value = is_same<T, char *>::value       ||
                   is_same<T, const char *>::value ||   
                   is_same<T, std::string>::value     };
};

template <typename T>
struct UsesStringDataWriter
{
    enum { value = is_same<T, char *>::value       ||
                   is_same<T, const char *>::value ||   
                   is_same<T, std::string>::value     };
};

template <typename T>
struct remove_const {
    typedef T type;
};

template <typename T>
struct remove_const<const T *> {
  typedef T * type;
};

template <typename T>
struct remove_const<const T **> {
  typedef T ** type;
};

template <typename T>
struct remove_const<const T ***> {
  typedef T *** type;
};

XMQCPPDllExport
SampleIdentity_t get_sample_identity_from_sample_info(const SampleInfo& info);

XMQCPPDllExport
SampleIdentity_t get_related_sample_identity_from_sample_info(
    const SampleInfo& info);

XMQCPPDllExport
DynamicDataTypeSupport * dynamic_data_type_support_cast(
        DDSTypeSupport * type_support);

/*i
 * @brief Implements the construction of a sample
 */
template <typename T, typename I>
class SampleBase {
public:
    typedef T        Data;
    typedef T&       DataReference;
    typedef const T& ConstDataReference;
    typedef I        Info;
    typedef typename dds_type_traits<T>::Seq         Seq;
    typedef typename dds_type_traits<T>::TypeSupport TypeSupport;
    typedef typename dds_type_traits<T>::DataReader  DataReader;
    typedef typename dds_type_traits<T>::DataWriter  DataWriter;

protected:
    typedef ConstDataReference DataInitType;

    void copy_from(ConstDataReference other_data)
    {
        const char * METHOD_NAME = "SampleBase::copy_from";
        if(TypeSupport::copy_data(&_data, &other_data) != DDS_RETCODE_OK) {
            check_retcode(DDS_RETCODE_ERROR, METHOD_NAME,
                          RTI_LOG_ANY_FAILURE_s, "copy sample data");
        }
    }

    void initialize()
    {
        const char * METHOD_NAME = "SampleBase::initialize";
        if (!_initialized) {
            if (TypeSupport::initialize_data(&_data) != DDS_RETCODE_OK) {
                check_retcode(DDS_RETCODE_ERROR, METHOD_NAME,
                              RTI_LOG_ANY_FAILURE_s, "initialize sample data");
            }

            if(_data_ptr && _info_ptr) {
                copy_from(*_data_ptr);
                _info = *_info_ptr;
            }

            _data_ptr = NULL;
            _info_ptr = NULL;
            _initialized = true;
        }
    }

    void clear()
    {
        if(_initialized) {
            TypeSupport::finalize_data(&_data);
            _data_ptr = NULL;
            _info_ptr = NULL;
            _initialized = false;
        }
    }

    void assign(const SampleBase & other)
    {
        if(other._initialized) {
            initialize();
            copy_from(other._data);
            _info = other._info;
        }
        else if(other._data_ptr && other._info_ptr) {
            initialize();
            copy_from(*other._data_ptr);
            _info = *other._info_ptr;
        }
        else 
            clear();
    }

    void construct(ConstDataReference data, const Info & info, bool init)
    {
        if(init) {
            initialize();
            copy_from(data);
            _info = info;
        }
        else {
            _data_ptr = & data;
            _info_ptr = & info;
        }
    }

    SampleBase()
        : _initialized(false),
          _data_ptr(NULL),
          _info_ptr(NULL)
    { }

    SampleBase(DataInitType data, const Info & info, bool init = true)
        : _initialized(false),
          _data_ptr(NULL),
          _info_ptr(NULL)
    {
        construct(data, info, init);
    }

    SampleBase(const SampleBase & other)
        : _initialized(false),
          _data_ptr(NULL),
          _info_ptr(NULL)
    {
        assign(other);
    }

    ~SampleBase()
    {
        clear();
    }

    SampleBase & operator = (const SampleBase & other)
    {
        // This implementation is not strongly exception-safe.
        if(this != &other)
            assign(other);

        return *this;
    }

public:

    void swap(SampleBase & other) 
    {
        using std::swap;

        swap(_initialized, other._initialized);
        swap(_data,        other._data);
        swap(_data_ptr,    other._data_ptr);
        swap(_info,        other._info);
        swap(_info_ptr,    other._info_ptr);
    }

    T& data() { 
        initialize(); 
        return _data; 
    }

    I& info() { 
        initialize();
        return _info; 
    }

    const T& data() const { 
        const_cast<SampleBase *>(this)->initialize(); 
        return _data;
    }

    const I& info() const { 
        const_cast<SampleBase *>(this)->initialize();
        return _info;
    }

    operator DataReference () {
        return data();
    }

    operator ConstDataReference () const {
        return data();
    }

    void set_data(const T & t) {
        data() = t;
    }

    void set_data(const T * t) {
        data() = *t;
    }

    void set_info(const I & i) {
        info() = i;
    }

    void set_info(const I * i) {
        info() = *i;
    }

protected:
    bool _initialized;
    T _data;
    const T * _data_ptr;
    I _info;
    const I * _info_ptr;
};

/* @ingroup PatternsInfrastructureModule
 *
 */
template <typename I>
class SampleBase<std::string, I> {
public:
    typedef std::string                       Data;
    typedef std::string &                     DataReference;
    typedef const std::string &               ConstDataReference;
    typedef I                                 Info;
    typedef dds_type_traits<std::string>::Seq Seq;
    typedef dds_type_traits<std::string>::DataReader DataReader;
    typedef dds_type_traits<std::string>::DataWriter DataWriter;

protected:
    typedef const char * DataInitType;

    void initialize()
    {
        if (!_initialized) {
            if(_data && _info_ptr) {
                _str.assign(_data);
                _info = *_info_ptr;
            }
            _data = NULL;
            _info_ptr = NULL;
            _initialized = true;
        }
    }

    void assign(const SampleBase & other) 
    {
        if(other._initialized) {
            _str = other._str;
            _info = other._info;
            _data = NULL;
            _info_ptr = NULL;
            _initialized = true;
        }
        else if (other._data && other._info_ptr) {
            _str.assign(other._data);
            _info = *other._info_ptr;
            _data = NULL;
            _info_ptr = NULL;
            _initialized = true;
        } 
        else { // otherwise just clear everything.
            _str.clear();
            _data = NULL;
            _info_ptr = NULL;
            _initialized = false;
        }
    }

    SampleBase()
        : _initialized(false), _data(NULL), _info_ptr(NULL)
    {}

    SampleBase(const std::string & str, 
               const Info & info)
        : _initialized(true), _str(str), _data(NULL), _info(info), _info_ptr(NULL)
    { }

    SampleBase(DataInitType str, const Info & info, bool init = true)
        : _initialized(false), _data(str), _info_ptr(&info)
    {
        if(init)
            initialize();
    }

    SampleBase(const SampleBase & other) 
        :_initialized(false), _data(NULL), _info_ptr(NULL)
    {
        assign(other);
    }

    SampleBase & operator = (const SampleBase & other)
    {
        if(this != &other) 
            assign(other);

        return *this;
    }

public:

    void swap(SampleBase & other) 
    {
        using std::swap;

        swap(_initialized, other._initialized);
        swap(_str,         other._str);
        swap(_data,        other._data);
        swap(_info,        other._info);
        swap(_info_ptr,    other._info_ptr);
    }

    const char * c_str() const {
        const_cast<SampleBase *>(this)->initialize();
        return _str.c_str();
    }

    std::string& data() { 
        initialize();
        return _str; 
    }

    I&  info() { 
        initialize();
        return _info; 
    }

    const std::string& data() const { 
        const_cast<SampleBase *>(this)->initialize();
        return _str; 
    }

    const I & info() const { 
        const_cast<SampleBase *>(this)->initialize();
        return _info; 
    }

    operator std::string& () {
        initialize();
        return data();
    }

    operator const std::string& () const {
        const_cast<SampleBase *>(this)->initialize();
        return data();
    }

    void set_data(const std::string & t) {
        data() = t;
    }

    void set_data(const std::string * t) {
        data() = *t;
    }

    void set_info(const I & i) {
        info() = i;
    }

    void set_info(const I * i) {
        info() = *i;
    }

protected:

    bool _initialized;
    std::string _str;
    const char * _data;
    Info _info;
    const Info * _info_ptr;
}; 

template <class T, class I>
class SampleBaseBuiltin  
{
public:

    static const int DEFAULT_KEY_SIZE;
    static const int DEFAULT_VALUE_SIZE ;

    SampleBaseBuiltin() 
      : _data(DEFAULT_KEY_SIZE, DEFAULT_VALUE_SIZE )
    { }

    SampleBaseBuiltin(int key_size, int value_size) 
      : _data(key_size, value_size)
    { }

    SampleBaseBuiltin(const SampleBaseBuiltin & other)
     : _data(other._data),
       _info(other._info)
    { }

    SampleBaseBuiltin(SampleRef<T> sample_ref)
      : _data(sample_ref.data()),
        _info(sample_ref.info())
    { }

    SampleBaseBuiltin(const T & data, const I & info, bool init = true)
     : _data(data),
       _info(info)
    { }

    SampleBaseBuiltin & operator = (SampleRef<T> sample_ref)
    {
        _data = sample_ref.data();
        _info = sample_ref.info();
        return *this;
    }

    void swap (SampleBaseBuiltin & other) 
    {
        _data.swap(other._data);
        std::swap(_info, other._info);
    }

    T & data() { 
        return _data; 
    }

    I & info() { 
        return _info; 
    }

    const T & data() const { 
        return _data;
    }

    const I & info() const { 
        return _info;
    }

    operator T & () {
        return data();
    }

    operator const T & () const {
        return data();
    }

    void set_data(const T & t) {
        data() = t;
    }

    void set_data(const T * t) {
        data() = *t;
    }

    void set_info(const I & i) {
        info() = i;
    }

    void set_info(const I * i) {
        info() = *i;
    }

protected:
    T _data;
    I _info;
};

template <class T, class I>
const int SampleBaseBuiltin<T,I>::DEFAULT_KEY_SIZE = 255;

template <class T, class I>
const int SampleBaseBuiltin<T,I>::DEFAULT_VALUE_SIZE  = 255;


template <class I, bool IsConst>
class SampleBaseCharPtr  
{
protected:

    typedef typename if_<IsConst, const char *, char *>::type CharPtr;

public:

    static const int DEFAULT_SIZE;

    SampleBaseCharPtr() 
      : _data(DDS_String_alloc(DEFAULT_SIZE))
    { }

    SampleBaseCharPtr(size_t size) 
        : _data(DDS_String_alloc(size))
    { }

    SampleBaseCharPtr(const char * ptr) 
        : _data(NULL)
    { 
        DDS_String_replace((char **) &_data, ptr);
    }

    SampleBaseCharPtr(const SampleBaseCharPtr & other)
     : _data(NULL),
       _info(other._info)
    { 
        DDS_String_replace((char **) &_data, other._data);
    }

    ~SampleBaseCharPtr()
    {
        if (_data) {
            DDS_String_free((char *) _data);
            _data = NULL;
        }
    }

    SampleBaseCharPtr(SampleRef<CharPtr> sample_ref)
      : _data(NULL),
        _info(sample_ref.info())
    { 
        DDS_String_replace((char **) &_data, sample_ref.data());
    }

    SampleBaseCharPtr(const char * data, const I & info, bool init = true)
     : _data(NULL),
       _info(info)
    { 
        DDS_String_replace((char **) &_data,data);
    }

    SampleBaseCharPtr & operator = (SampleRef<CharPtr> sample_ref)
    {
        SampleBaseCharPtr(sample_ref).swap(*this);
        return *this;
    }

    SampleBaseCharPtr & operator = (const char * ptr)
    {
        SampleBaseCharPtr(ptr).swap(*this);
        return *this;
    }

    void swap (SampleBaseCharPtr & other) 
    {
        using std::swap;
        swap(_data, other._data);
        swap(_info, other._info);
    }

    CharPtr & data() { 
        return _data; 
    }

    I & info() { 
        return _info; 
    }

    const CharPtr & data() const { 
        return _data;
    }

    const I & info() const { 
        return _info;
    }

    void set_data(const char * ptr) {
       DDS_String_replace((char **) &_data, ptr);
    }

    void set_info(const I & i) {
        info() = i;
    }

    void set_info(const I * i) {
        info() = *i;
    }

protected:
    CharPtr _data;
    I _info;
};

template <class I, bool IsConst>
const int SampleBaseCharPtr<I, IsConst>::DEFAULT_SIZE = 255;

} // namespace details

/**
 * \dref_Sample
 */
template <typename T>
class Sample : public details::SampleBase<T, SampleInfo> {

protected:
    typedef details::SampleBase<T, SampleInfo> Super;
    typedef typename Super::DataInitType DataInitType;

public:

    /**
     * \dref_Sample_new
     */
    Sample() 
     : Super()
    {}

    /**
     * \dref_Sample_copy
     */
    Sample(const Sample<T>& other)
     : Super(other.data(), other.info())
    {}

    /**
     * \dref_Sample_new_from_sampleref
     */
    Sample(SampleRef<T> sample_ref);

    /*i
     *
     */
    Sample(DataInitType data, const SampleInfo& info, bool init = true)
     : Super(data, info, init)
    {}

    Sample & operator = (SampleRef<T> sample_ref);

    /**
     * \dref_Sample_identity
     */
    SampleIdentity_t identity() const {
        return details::get_sample_identity_from_sample_info(this->info());
    }

    /**
     * \dref_Sample_related_identity
     */
    SampleIdentity_t related_identity() const {
        return details::get_related_sample_identity_from_sample_info(this->info());
    }





};

template <>
class Sample<DDS::KeyedString> 
    : public details::SampleBaseBuiltin<DDS::KeyedString, SampleInfo> 
{
private:

    typedef details::SampleBaseBuiltin<DDS::KeyedString, SampleInfo>  super;

    void throw_if_bad() 
    {
        const char * METHOD_NAME = "Sample<DDS::KeyedSting>::Sample";
        if (!_data.is_allocated()) {
            check_retcode(DDS_RETCODE_OUT_OF_RESOURCES,
                          METHOD_NAME,
                          DDS_LOG_BAD_PARAMETER_s, "DDS::KeyedString failed to allocate memory");
        }
    }

public:

    Sample() 
      : super(DEFAULT_KEY_SIZE, DEFAULT_VALUE_SIZE )
    { 
        throw_if_bad();
    }

    Sample(int key_size, int value_size) 
      : super(key_size, value_size)
    {
        throw_if_bad();
    }

    Sample(const Sample<DDS::KeyedString>& other)
     : super(other)
    {
        throw_if_bad();
    }

    Sample(SampleRef<DDS::KeyedString> sample_ref);

    Sample(const DDS::KeyedString & data, const SampleInfo& info, bool init = true)
     : super(data, info, init)
    {
        throw_if_bad();
    }

    SampleIdentity_t identity() const {
        return details::get_sample_identity_from_sample_info(this->info());
    }

    SampleIdentity_t related_identity() const {
        return details::get_related_sample_identity_from_sample_info(this->info());
    }
};

template <>
class Sample<DDS::KeyedOctets> 
    : public details::SampleBaseBuiltin<DDS::KeyedOctets, SampleInfo> 
{
private:

    typedef details::SampleBaseBuiltin<DDS::KeyedOctets, SampleInfo>  super;

    void throw_if_bad() 
    {
        const char * METHOD_NAME = "Sample<DDS::KeyedOctets>::Sample";
        if (!_data.is_allocated()) {
            check_retcode(DDS_RETCODE_OUT_OF_RESOURCES,
                          METHOD_NAME,
                          DDS_LOG_BAD_PARAMETER_s, "DDS::KeyedOctets failed to allocate memory");
        }
    }


public:

    Sample() 
      : super(DEFAULT_KEY_SIZE, DEFAULT_VALUE_SIZE )
    { 
        throw_if_bad();
    }

    Sample(int key_size, int value_size) 
      : super(key_size, value_size)
    {
        throw_if_bad();
    }

    Sample(const Sample<DDS::KeyedOctets>& other)
     : super(other)
    {
        throw_if_bad();
    }

    Sample(SampleRef<DDS::KeyedOctets> sample_ref);

    Sample(const DDS::KeyedOctets & data, const SampleInfo& info, bool init = true)
     : super(data, info, init)
    {
        throw_if_bad();
    }

    SampleIdentity_t identity() const {
        return details::get_sample_identity_from_sample_info(this->info());
    }

    SampleIdentity_t related_identity() const {
        return details::get_related_sample_identity_from_sample_info(this->info());
    }
};

template <>
class Sample<DDS::Octets>  
{
    void throw_if_bad() 
    {
        const char * METHOD_NAME = "Sample<DDS::Octets>::Sample";
        if (!_data.is_allocated()) {
            check_retcode(DDS_RETCODE_OUT_OF_RESOURCES,
                          METHOD_NAME,
                          DDS_LOG_BAD_PARAMETER_s, "DDS::Octets failed to allocate memory");
        }
    }

public:

    static const int DEFAULT_VALUE_SIZE ;

    Sample() 
      : _data(DEFAULT_VALUE_SIZE )
    { 
        throw_if_bad();
    }

    Sample(int value_size) 
      : _data(value_size)
    { 
        throw_if_bad();
    }

    Sample(const Sample & other)
     : _data(other._data),
       _info(other._info)
    { 
        throw_if_bad();
    }

    Sample(SampleRef<DDS::Octets> sample_ref);

    Sample(const DDS::Octets & data, const SampleInfo & info, bool init = true)
     : _data(data),
       _info(info)
    { 
        throw_if_bad();
    }

    Sample & operator = (SampleRef<DDS::Octets> sample_ref);

    void swap (Sample & other) 
    {
        _data.swap(other._data);
        std::swap(_info, other._info);
    }

    SampleIdentity_t identity() const {
        return details::get_sample_identity_from_sample_info(this->info());
    }

    SampleIdentity_t related_identity() const {
        return details::get_related_sample_identity_from_sample_info(this->info());
    }

    DDS::Octets & data() { 
        return _data; 
    }

    SampleInfo & info() { 
        return _info; 
    }

    const DDS::Octets & data() const { 
        return _data;
    }

    const SampleInfo & info() const { 
        return _info;
    }

    operator DDS::Octets & () {
        return data();
    }

    operator const DDS::Octets & () const {
        return data();
    }

    void set_data(const DDS::Octets & t) {
        data() = t;
    }

    void set_data(const DDS::Octets * t) {
        data() = *t;
    }

    void set_info(const SampleInfo & i) {
        info() = i;
    }

    void set_info(const SampleInfo * i) {
        info() = *i;
    }

protected:
    DDS::Octets _data;
    SampleInfo _info;
};


template<>
class Sample<char *> : public details::SampleBaseCharPtr<SampleInfo, false>
{
    typedef details::SampleBaseCharPtr<SampleInfo, false> super;

    void throw_if_bad() 
    {
        const char * METHOD_NAME = "Sample<char *>::Sample";
        if (!_data) {
            check_retcode(DDS_RETCODE_OUT_OF_RESOURCES,
                          METHOD_NAME,
                          DDS_LOG_BAD_PARAMETER_s, "DDS_String_alloc failed to allocate memory");
        }
    }

public:

    Sample() 
      : super()
    { 
        throw_if_bad();
        *_data = '\0';
    }

    Sample(size_t size) 
        : super(size)
    { 
        throw_if_bad();
        *_data = '\0';
    }

    Sample(const char * ptr) 
        : super(ptr)
    { 
        throw_if_bad();
    }

    Sample(const Sample & other)
     : super(other)
    { 
        throw_if_bad();
    }

    Sample(SampleRef<char *> sample_ref);

    Sample(const char * data, const SampleInfo & info, bool init = true)
     : super(data, info, init)
    { 
        throw_if_bad();
    }

    Sample & operator = (SampleRef<char *> sample_ref);

    Sample & operator = (const char * ptr)
    {
        super::operator = (ptr);
        return *this;
    }

    SampleIdentity_t identity() const {
        return details::get_sample_identity_from_sample_info(this->info());
    }

    SampleIdentity_t related_identity() const {
        return details::get_related_sample_identity_from_sample_info(this->info());
    }
};

template<>
class Sample<const char *> : public details::SampleBaseCharPtr<SampleInfo, true>
{
    typedef details::SampleBaseCharPtr<SampleInfo, true> super;

    void throw_if_bad() 
    {
        const char * METHOD_NAME = "Sample<const char *>::Sample";
        if (!_data) {
            check_retcode(DDS_RETCODE_OUT_OF_RESOURCES,
                          METHOD_NAME,
                          DDS_LOG_BAD_PARAMETER_s, "DDS_String_alloc failed to allocate memory");
        }
    }

public:

    Sample() 
      : super()
    { 
        throw_if_bad();
        *((char *) _data) = '\0';
    }

    Sample(size_t size) 
        : super(size)
    { 
        throw_if_bad();
        *((char *) _data) = '\0';
    }

    Sample(const char * ptr) 
        : super(ptr)
    { 
        throw_if_bad();
    }

    Sample(const Sample & other)
     : super(other)
    { 
        throw_if_bad();
    }

    Sample(SampleRef<const char *> sample_ref);

    Sample(const char * data, const SampleInfo & info, bool init = true)
     : super(data, info, init)
    { 
        throw_if_bad();
    }

    Sample & operator = (SampleRef<const char *> sample_ref);

    Sample & operator = (const char * ptr)
    {
        super::operator = (ptr);
        return *this;
    }

    SampleIdentity_t identity() const {
        return details::get_sample_identity_from_sample_info(this->info());
    }

    SampleIdentity_t related_identity() const {
        return details::get_related_sample_identity_from_sample_info(this->info());
    }
};

/**
 * \dref_SampleRef
 */
template <typename T>
class SampleRef
{
public:
    typedef typename details::if_<details::is_const<T>::value,
                                  const SampleInfo,
                                  SampleInfo>::type Info;

    /**
     * \dref_SampleRef_new
     */
    SampleRef() 
        : _data_ptr(NULL),
          _info_ptr(NULL)
    {}

    /**
     * \dref_SampleRef_new_w_data
     */
    SampleRef(T * data, Info * info)
        : _data_ptr(data),
          _info_ptr(info)
    {}

    /**
     * \dref_SampleRef_new_w_data
     */
    SampleRef(T & data, Info & info)
        : _data_ptr(&data),
          _info_ptr(&info)
    {}

    /**
     * \dref_SampleRef_copy
     */
    SampleRef(Sample<T> & sample)
        : _data_ptr(&sample.data()),
          _info_ptr(&sample.info())
    {}

    /**
     * \dref_SampleRef_copy
     */
    SampleRef & operator = (Sample<T> & sample)
    {
      SampleRef(sample).swap(*this);
      return *this;
    }

    /**
     * \dref_SampleRef_data
     */
    T & data() const { 
        return *_data_ptr;
    }

    /**
     * \dref_SampleRef_info
     */
    Info & info() const { 
        return *_info_ptr;
    }

    /**
     * \dref_SampleRef_data
     */
    operator T & () const {
        return *_data_ptr;
    }

    /**
     */
    SampleRef<T> * operator ->() {
        return this;
    }

    /**
     */
    const SampleRef<T> * operator ->() const {
        return this;
    }

    void set_data(T * data) {
        _data_ptr = data;
    }

    /**
     * \dref_SampleRef_set_data
     */
    void set_data(T & data) {
        _data_ptr = &data;
    }

    void set_info(Info * info) {
        _info_ptr = info;
    }




    void set_info(Info & info) {
        _info_ptr = &info;
    }


    /**
     * \dref_SampleRef_is_nil_data
     */
    bool is_nil_data() const {
        return (_data_ptr == NULL);
    }

    /**
     * \dref_SampleRef_is_nil_info
     */
    bool is_nil_info() const {
        return (_info_ptr == NULL);
    }

    void swap(SampleRef & other) throw()
    {
        using std::swap;

        swap(_data_ptr, other._data_ptr);
        swap(_info_ptr, other._info_ptr);
    }

    /**
     * \dref_SampleRef_identity
     */
    SampleIdentity_t identity() const {
        return details::get_sample_identity_from_sample_info(this->info());
    }

    /**
     * \dref_SampleRef_related_identity
     */
    SampleIdentity_t related_identity() const {
        return details::get_related_sample_identity_from_sample_info(this->info());
    }

private:
    T *    _data_ptr;
    Info * _info_ptr;
};

template <>
class SampleRef<char *> 
{
public:

    typedef SampleInfo Info;

    SampleRef() 
    : _data_ptr(NULL),
      _info_ptr(NULL)
    {}

    SampleRef(char * data, SampleInfo * info)
        : _data_ptr(data),
          _info_ptr(info)
    {}

    SampleRef(char * data, SampleInfo & info)
        : _data_ptr(data),
          _info_ptr(&info)
    {}

    const char * c_str() const {
        return _data_ptr;
    }

    char * & data() { 
        return _data_ptr;
    }

    char * const & data() const { 
        return _data_ptr;
    }

    Info & info() const { 
        return *_info_ptr;
    }

    operator std::string () const {
        return std::string(_data_ptr);
    }

    SampleRef<char *> * operator ->() {
        return this;
    }

    const SampleRef<char *> * operator ->() const {
        return this;
    }

    void set_data(char * data) {
        _data_ptr = data;
    }

    void set_info(SampleInfo * info) {
        _info_ptr = info;
    }

    void set_info(SampleInfo & info) {
        _info_ptr = &info;
    }

    bool is_nil_data() const {
        return (_data_ptr == NULL);
    }

    bool is_nil_info() const {
        return (_info_ptr == NULL);
    }

    void swap(SampleRef & other) 
    {
        using std::swap;

        swap(_data_ptr, other._data_ptr);
        swap(_info_ptr, other._info_ptr);
    }

    SampleIdentity_t identity() const {
        return details::get_sample_identity_from_sample_info(this->info());
    }

    SampleIdentity_t related_identity() const {
        return details::get_related_sample_identity_from_sample_info(this->info());
    }

private:
    char *        _data_ptr;
    SampleInfo *  _info_ptr;
};

template <>
class SampleRef<const char *> 
{
public:

    typedef const SampleInfo Info;

    SampleRef() 
        : _data_ptr(NULL),
          _info_ptr(NULL)
    {}

    SampleRef(const char * data, const SampleInfo * info)
        : _data_ptr(data),
          _info_ptr(info)
    {}

    SampleRef(const char * data, const SampleInfo &info)
        : _data_ptr(data),
          _info_ptr(&info)
    { }

    SampleRef(SampleRef<char *> sample)
     : _data_ptr(sample.data()),
       _info_ptr(&sample.info())
    {}

    SampleRef & operator = (SampleRef<char *> sample)
    {
       SampleRef(sample).swap(*this);
       return *this;
    }

    const char * c_str() const {
        return _data_ptr;
    }

    const char * & data() { 
        return _data_ptr;
    }

    const char * const & data() const { 
        return _data_ptr;
    }

    Info & info() const { 
        return *_info_ptr;
    }

    operator std::string () const {
        return std::string(_data_ptr);
    }

    SampleRef<const char *> * operator ->() {
        return this;
    }

    const SampleRef<const char *> * operator ->() const {
        return this;
    }

    void set_data(const char * data) {
        _data_ptr = data;
    }

    void set_info(const SampleInfo * info) {
        _info_ptr = info;
    }

    void set_info(const SampleInfo & info) {
        _info_ptr = &info;
    }

    bool is_nil_data() const {
        return (_data_ptr == NULL);
    }

    bool is_nil_info() const {
        return (_info_ptr == NULL);
    }

    void swap(SampleRef & other) 
    {
        using std::swap;

        swap(_data_ptr, other._data_ptr);
        swap(_info_ptr, other._info_ptr);
    }

    SampleIdentity_t identity() const {
        return details::get_sample_identity_from_sample_info(this->info());
    }

    SampleIdentity_t related_identity() const {
        return details::get_related_sample_identity_from_sample_info(this->info());
    }

private:
    const char *       _data_ptr;
    const SampleInfo * _info_ptr;
};

//template <>
//class SampleRef<std::string>
//{
//  // Invalid type.
//};

template <>
class Sample<std::string> 
    : public details::SampleBase<std::string, SampleInfo> 
{
protected:
    typedef details::SampleBase<std::string, SampleInfo> Super;
    typedef Super::DataInitType DataInitType;

public:

    Sample() 
      : Super()
    {}

    Sample(DataInitType data, const SampleInfo& info, bool init = true)
        : Super(data, info, init)
    {}

    Sample(const std::string & str, const SampleInfo& info, bool = true)
        : Super(str, info)
    {}

    Sample(SampleRef<char *> sample)
      : Super(sample.data(), sample.info())
    {}    

    Sample(SampleRef<const char *> sample)
      : Super(sample.data(), sample.info())
    {}

    Sample & operator = (SampleRef<char *> sample_ref)
    {
       // Copy and swap
       Sample(sample_ref).swap(*this);
       return *this;
    }

    Sample & operator = (SampleRef<const char *> sample_ref)
    {
        // Copy and swap
        Sample(sample_ref).swap(*this);
        return *this;
    }

    SampleIdentity_t identity() const {
        return details::get_sample_identity_from_sample_info(this->info());
    }

    SampleIdentity_t related_identity() const {
        return details::get_related_sample_identity_from_sample_info(
            this->info());
    }
};

template <typename T>
Sample<T>::Sample(SampleRef<T> sample_ref)
 : Super(sample_ref.data(), sample_ref.info())
{}

template <typename T>
Sample<T> & Sample<T>::operator = (SampleRef<T> sample_ref)
{
    Sample<T>(sample_ref).swap(*this);
    return *this;
}

template <class T>
void swap(Sample<T> & s1, Sample<T> & s2)
{
    s1.swap(s2);
}

template <class T>
void swap(SampleRef<T> & s1, SampleRef<T> & s2)
{
    s1.swap(s2);
}

template <typename T>
class WriteSampleRef;

/**
 * \dref_WriteSample
 */
template <typename T>
class WriteSample : public details::SampleBase<T, WriteParams_t> {
protected:
    typedef details::SampleBase<T, WriteParams_t> Super;
    typedef typename Super::DataInitType DataInitType;

public:

    /**
     * \dref_WriteSample_new
     */
    WriteSample() 
        : Super()
    {}

    /**
     * \dref_WriteSample_copy
     */
    WriteSample(const WriteSample<T>& other)
        : Super(other.data(), other.info())
    {}

    /*i
     *
     */
    WriteSample(DataInitType data, WriteParams_t& info)
        : Super(data, info)
    {}




    WriteSample(DataInitType data)
        : Super(data, WriteParams_t())
    {}

    /**
     * \dref_WriteSample_new_from_writesampleref
     */
    WriteSample(WriteSampleRef<T> wsref)
        : Super(wsref.data(), wsref.info())
    {}

    WriteSample & operator = (WriteSampleRef<T> wsref)
    {
        WriteSample<T>(wsref).swap(*this);
        return *this;
    }




    /**
     * \dref_WriteSample_identity
     */
    SampleIdentity_t identity() const {
        return this->info().identity;
    }
};

template <>
class WriteSample<DDS::KeyedString> 
    : public details::SampleBaseBuiltin<DDS::KeyedString, WriteParams_t> 
{
    void throw_if_bad() 
    {
        const char * METHOD_NAME = "WriteSample<DDS::KeyedSting>::WriteSample";
        if (!_data.is_allocated()) {
            check_retcode(DDS_RETCODE_OUT_OF_RESOURCES,
                          METHOD_NAME,
                          DDS_LOG_BAD_PARAMETER_s, "DDS::KeyedString failed to allocate memory");
        }
    }

protected:
    typedef details::SampleBaseBuiltin<DDS::KeyedString, WriteParams_t> super;

public:

    WriteSample() 
        : super()
    {
        throw_if_bad();
    }

    WriteSample(int key_size, int value_size) 
      : super(key_size, value_size)
    {
        throw_if_bad();
    }

    WriteSample(const WriteSample & other)
        : super(other)
    {
        throw_if_bad();
    }

    WriteSample(const DDS::KeyedString & data, const WriteParams_t& info)
        : super(data, info)
    {
        throw_if_bad();
    }

    WriteSample(const DDS::KeyedString & data)
        : super(data, WriteParams_t())
    {
        throw_if_bad();
    }

    WriteSample(WriteSampleRef<DDS::KeyedString> wsref);

    WriteSample & operator = (WriteSampleRef<DDS::KeyedString> wsref);

    SampleIdentity_t identity() const {
        return this->info().identity;
    }
};

template <>
class WriteSample<DDS::KeyedOctets> 
    : public details::SampleBaseBuiltin<DDS::KeyedOctets, WriteParams_t> 
{
    void throw_if_bad() 
    {
        const char * METHOD_NAME = "WriteSample<DDS::KeyedOctets>::WriteSample";
        if (!_data.is_allocated()) {
            check_retcode(DDS_RETCODE_OUT_OF_RESOURCES,
                          METHOD_NAME,
                          DDS_LOG_BAD_PARAMETER_s, "DDS::KeyedOctets failed to allocate memory");
        }
    }

protected:
    typedef details::SampleBaseBuiltin<DDS::KeyedOctets, WriteParams_t> super;

public:

    WriteSample() 
        : super()
    {
        throw_if_bad();
    }

    WriteSample(int key_size, int value_size) 
      : super(key_size, value_size)
    {
        throw_if_bad();
    }

    WriteSample(const WriteSample & other)
        : super(other)
    {
        throw_if_bad();
    }

    WriteSample(const DDS::KeyedOctets & data, const WriteParams_t& info)
        : super(data, info)
    {
        throw_if_bad();
    }

    WriteSample(const DDS::KeyedOctets & data)
        : super(data, WriteParams_t())
    {
        throw_if_bad();
    }

    WriteSample(WriteSampleRef<DDS::KeyedOctets> wsref);

    WriteSample & operator = (WriteSampleRef<DDS::KeyedOctets> wsref);

    SampleIdentity_t identity() const {
        return this->info().identity;
    }
};

template <>
class WriteSample<DDS::Octets>  
{
    void throw_if_bad() 
    {
        const char * METHOD_NAME = "WriteSample<DDS::Octets>::WriteSample";
        if (!_data.is_allocated()) {
            check_retcode(DDS_RETCODE_OUT_OF_RESOURCES,
                          METHOD_NAME,
                          DDS_LOG_BAD_PARAMETER_s, "DDS::Octets failed to allocate memory");
        }
    }

public:

    static const int DEFAULT_VALUE_SIZE ;

    WriteSample() 
      : _data(DEFAULT_VALUE_SIZE )
    { 
        throw_if_bad();
    }

    WriteSample(int value_size) 
      : _data(value_size)
    { 
        throw_if_bad();
    }

    WriteSample(const WriteSample & other)
     : _data(other._data),
       _info(other._info)
    { 
        throw_if_bad();
    }

    WriteSample(WriteSampleRef<DDS::Octets> sample_ref);

    WriteSample(const DDS::Octets & data, const WriteParams_t & info, bool init = true)
     : _data(data),
       _info(info)
    { 
        throw_if_bad();
    }

    WriteSample & operator = (WriteSampleRef<DDS::Octets> sample_ref);

    void swap (WriteSample & other) 
    {
        _data.swap(other._data);
        std::swap(_info, other._info);
    }

    DDS::Octets & data() { 
        return _data; 
    }

    WriteParams_t & info() { 
        return _info; 
    }

    const DDS::Octets & data() const { 
        return _data;
    }

    const WriteParams_t & info() const { 
        return _info;
    }

    operator DDS::Octets & () {
        return data();
    }

    operator const DDS::Octets & () const {
        return data();
    }

    void set_data(const DDS::Octets & t) {
        data() = t;
    }

    void set_data(const DDS::Octets * t) {
        data() = *t;
    }

    void set_info(const WriteParams_t & i) {
        info() = i;
    }

    void set_info(const WriteParams_t * i) {
        info() = *i;
    }

    SampleIdentity_t identity() const {
        return this->info().identity;
    }

private:
    DDS::Octets _data;
    WriteParams_t _info;
};


template<>
class WriteSample<char *> : public details::SampleBaseCharPtr<WriteParams_t, false>
{
    typedef details::SampleBaseCharPtr<WriteParams_t, false> super;

    void throw_if_bad() 
    {
        const char * METHOD_NAME = "WriteSample<char *>::Sample";
        if (!_data) {
            check_retcode(DDS_RETCODE_OUT_OF_RESOURCES,
                          METHOD_NAME,
                          DDS_LOG_BAD_PARAMETER_s, "DDS_String_alloc failed to allocate memory");
        }
    }

public:

    WriteSample() 
      : super()
    { 
        throw_if_bad();
        *_data = '\0';
    }

    WriteSample(size_t size) 
        : super(size)
    { 
        throw_if_bad();
        *_data = '\0';
    }

    WriteSample(const char * ptr) 
        : super(ptr)
    { 
        throw_if_bad();
    }

    WriteSample(const WriteSample & other)
     : super(other)
    { 
        throw_if_bad();
    }

    WriteSample(WriteSampleRef<char *> sample_ref);

    WriteSample(const char * data, const WriteParams_t & info, bool init = true)
     : super(data, info, init)
    { 
        throw_if_bad();
    }

    WriteSample & operator = (WriteSampleRef<char *> sample_ref);

    WriteSample & operator = (const char * ptr)
    {
        super::operator = (ptr);
        return *this;
    }

    SampleIdentity_t identity() const {
        return this->info().identity;
    }
};

template<>
class WriteSample<const char *> 
   : public details::SampleBaseCharPtr<WriteParams_t, true>
{
    typedef details::SampleBaseCharPtr<WriteParams_t, true> super;

    void throw_if_bad() 
    {
        const char * METHOD_NAME = "WriteSample<const char *>::Sample";
        if (!_data) {
            check_retcode(DDS_RETCODE_OUT_OF_RESOURCES,
                          METHOD_NAME,
                          DDS_LOG_BAD_PARAMETER_s, "DDS_String_alloc failed to allocate memory");
        }
    }

public:

    WriteSample() 
      : super()
    { 
        throw_if_bad();
        *((char *)_data) = '\0';
    }

    WriteSample(size_t size) 
        : super(size)
    { 
        throw_if_bad();
        *((char *)_data) = '\0';
    }

    WriteSample(const char * ptr) 
        : super(ptr)
    { 
        throw_if_bad();
    }

    WriteSample(const WriteSample & other)
     : super(other)
    { 
        throw_if_bad();
    }

    WriteSample(WriteSampleRef<const char *> sample_ref);

    WriteSample(const char * data, const WriteParams_t & info, bool init = true)
     : super(data, info, init)
    { 
        throw_if_bad();
    }

    WriteSample & operator = (WriteSampleRef<const char *> sample_ref);

    WriteSample & operator = (const char * ptr)
    {
        super::operator = (ptr);
        return *this;
    }

    SampleIdentity_t identity() const {
        return this->info().identity;
    }
};

template <>
class WriteSample<std::string> 
    : public details::SampleBase<std::string, WriteParams_t>
{
protected:
    typedef details::SampleBase<std::string, WriteParams_t> Super;
    typedef Super::DataInitType DataInitType;

public:

    WriteSample() 
        : Super()
    {}

    WriteSample(DataInitType data, const WriteParams_t& info)
        : Super(data, info)
    {}

    WriteSample(DataInitType data)
        : Super(data, WriteParams_t())
    {}

    WriteSample(const std::string & str, const WriteParams_t& info)
        : Super(str, info)
    {}

    WriteSample(const std::string & str)
        : Super(str, WriteParams_t())
    {}

    WriteSample(WriteSampleRef<std::string> wsref);
    WriteSample & operator = (WriteSampleRef<std::string> wsref);

    SampleIdentity_t identity() const {
        return this->info().identity;
    }
};



/**
 * \dref_WriteSampleRef
 */
template <typename T>
class WriteSampleRef 
{
public:

    /**
     * \dref_WriteSampleRef_new
     */
    WriteSampleRef() 
    : _data_ptr(NULL),
      _info_ptr(NULL)
    {}


    /**
     * \dref_WriteSampleRef_new_w_data
     */
    WriteSampleRef(T & data, WriteParams_t & wparams)
        : _data_ptr(&data),
          _info_ptr(&wparams)
    { }

    /**
     * \dref_WriteSampleRef_copy
     */
    WriteSampleRef(WriteSample<T> & ws)
        : _data_ptr(&ws.data()),
          _info_ptr(&ws.info())
    {}

    WriteSampleRef & operator = (WriteSample<T> & ws)
    {
        WriteSampleRef(ws).swap(*this);
        return *this;
    }


    /**
     * \dref_WriteSampleRef_data
     */
    T & data() const { 
        return *_data_ptr;
    }

    /**
     * \dref_WriteSampleRef_info
     */
    WriteParams_t & info() const { 
        return *_info_ptr;
    }

    /**
     * \dref_WriteSampleRef_set_data
     */
    void set_data(T & data) {
        _data_ptr = &data;
    }

    void set_data(T * data) {
        _data_ptr = data;
    }

    /**
     * \dref_WriteSampleRef_set_info
     */
    void set_info(WriteParams_t & info) {
        _info_ptr = &info;
    }

    void set_info(WriteParams_t * info) {
        _info_ptr = info;
    }

    /**
     * \dref_WriteSampleRef_is_nil_data
     */
    bool is_nil_data() const {
        return (_data_ptr == NULL);
    }

    bool is_nil_info() const {
        return (_info_ptr == NULL);
    }

    void swap(WriteSampleRef & other) 
    {
        using std::swap;

        swap(_data_ptr, other._data_ptr);
        swap(_info_ptr, other._info_ptr);
    }

    /**
     * \dref_WriteSampleRef_identity
     */
    SampleIdentity_t identity() const {
        return this->info().identity;
    }

private:
    T *  _data_ptr;
    WriteParams_t * _info_ptr;
};

template <>
class WriteSampleRef<const char *> 
{
public:

    WriteSampleRef() 
    : _data_ptr(NULL),
      _info_ptr(NULL)
    {}

    WriteSampleRef(const char * data, WriteParams_t & wparams)
        : _data_ptr(data),
		  _info_ptr(&wparams)
    { }

    const char * c_str() const {
        return _data_ptr;
    }

    const char * & data() { 
        return _data_ptr;
    }

    const char * const & data() const { 
        return _data_ptr;
    }

    WriteParams_t & info() const { 
        return *_info_ptr;
    }

    void set_data(const char * data) {
        _data_ptr = data;
    }

    void set_info(WriteParams_t & info) {
        _info_ptr = &info;
    }

    void set_info(WriteParams_t * info) {
        _info_ptr = info;
    }

    bool is_nil_data() const {
        return (_data_ptr == NULL);
    }

    bool is_nil_info() const {
        return (_info_ptr == NULL);
    }

    void swap(WriteSampleRef & other) 
    {
        using std::swap;

        swap(_data_ptr, other._data_ptr);
        swap(_info_ptr, other._info_ptr);
    }

    SampleIdentity_t identity() const {
        return this->info().identity;
    }

private:
    const char * _data_ptr;
    WriteParams_t * _info_ptr;
};

template <>
class WriteSampleRef<char *> 
{
public:

    WriteSampleRef() 
        : _data_ptr(NULL),
          _info_ptr(NULL)
    {}

    WriteSampleRef(char * data, WriteParams_t & wparams)
        : _data_ptr(data),
          _info_ptr(&wparams)
    { }

    const char * c_str() const {
        return _data_ptr;
    }

    char * & data() { 
        return _data_ptr;
    }

    char * const & data() const { 
        return _data_ptr;
    }

    WriteParams_t & info() const { 
        return *_info_ptr;
    }

    void set_data(char * data) {
        _data_ptr = data;
    }

    void set_info(WriteParams_t & info) {
        _info_ptr = &info;
    }

    void set_info(WriteParams_t * info) {
        _info_ptr = info;
    }

    bool is_nil_data() const {
        return (_data_ptr == NULL);
    }

    bool is_nil_info() const {
        return (_info_ptr == NULL);
    }

    void swap(WriteSampleRef & other) 
    {
        using std::swap;

        swap(_data_ptr, other._data_ptr);
        swap(_info_ptr, other._info_ptr);
    }

    SampleIdentity_t identity() const {
        return this->info().identity;
    }

private:
    char * _data_ptr;
    WriteParams_t  * _info_ptr;
};

template <class T>
void swap(WriteSample<T> & ws1, WriteSample<T> & ws2) throw()
{
   ws1.swap(ws2);
}

template <class T>
void swap(WriteSampleRef<T> & ws1, WriteSampleRef<T> & ws2) throw()
{
   ws1.swap(ws2);
}

/**
 * @ingroup PatternsInfrastructureModule
 * @brief Predicate-class to determine if a sample contains valid data
 *
 * Useful for C++ standard algorithms like <tt>std::copy()</tt>
 *
 * @see \ref RequestReplyExampleModule_get_copied_samples
 */

template <typename T>
class IsValidSamplePredicate {
public:
    bool operator ()(SampleRef<T> sample) const
    {
        return sample.info().valid_data;
    } 
};

/**
 * @ingroup PatternsInfrastructureModule
 * @brief Predicate-class to determine if a sample contains invalid data
 *
 */
template <typename T>
class IsInvalidSamplePredicate {
public:
    bool operator ()(SampleRef<T> sample) const
    {
        return !sample.info().valid_data;
    }
};

/**
 * @ingroup PatternsInfrastructureModule
 * @brief Predicate-class to match replies by their related request
 *
 * Useful for C++ standard algorithms like <tt>std::find_if()</tt>
 *
 * @see \ref RequestReplyExampleModule_correlation
 */
template <typename T>
class IsReplyRelatedPredicate {
public:

    /**
     * @brief Creates the predicate with the request id to match
     */
    IsReplyRelatedPredicate(const DDS::SampleIdentity_t& related_request_id)
        : _related_request_id(related_request_id)
    {
    }

    IsReplyRelatedPredicate(const IsReplyRelatedPredicate<T>& other)
        : _related_request_id(other._related_request_id)
    {
    }

    /**
     * @brief Determines if a reply is related to the request id this object
     * contains
     */
    inline bool operator ()(SampleRef<T> sample)
    {
        return sample.related_identity() == _related_request_id;
    }
private:
    DDS::SampleIdentity_t _related_request_id;
};

/**
 * @ingroup PatternsInfrastructureModule
 *
 * @brief STL-compliant random-access iterator for SampleRef<T>
 * @see \idref_LoanedContainer_begin
 */
template <typename T, bool IsConst>
class SampleIterator 
{
public:
   typedef std::random_access_iterator_tag iterator_category;

   typedef typename details::if_<
       IsConst, 
       typename dds_type_traits<T>::ConstSampleIteratorValueType, 
       typename dds_type_traits<T>::SampleIteratorValueType>::type value_type;

   typedef value_type reference;
   typedef value_type pointer;
   typedef std::ptrdiff_t difference_type;

   typedef typename dds_type_traits<T>::Seq Seq;

   typedef typename details::if_<
       IsConst, 
       typename dds_type_traits<T>::ConstSeq, 
       typename dds_type_traits<T>::Seq>::type TSeq;

   typedef typename details::if_<
       IsConst, 
       typename dds_type_traits<SampleInfo>::ConstSeq, 
       typename dds_type_traits<SampleInfo>::Seq>::type InfoSeq;

   SampleIterator()
     : _seq(0),
       _info_seq(0),
       _pos(0)
   {}

   explicit SampleIterator(TSeq & seq, 
                           InfoSeq & info_seq, 
                           int position = 0)
     : _seq(&seq),
       _info_seq(&info_seq),
       _pos(position)
   {}

   SampleIterator (const SampleIterator<T, false> & si)
     : _seq(si._seq),
       _info_seq(si._info_seq),
       _pos(si._pos)
   {}

   SampleIterator & operator = (const SampleIterator<T, false> & si)
   {
     _seq      = si._seq;
     _info_seq = si._info_seq;
     _pos      = si._pos;

     return *this;
   }

   template <bool IsConstValidSampleIter>
   explicit SampleIterator(ValidSampleIterator<T, IsConstValidSampleIter> valid_it)
       : _seq(0),
         _info_seq(0),
         _pos(0)
   { 
       *this = valid_it.underlying();
   }

   value_type operator * () const {
     return value_type((*_seq)[_pos], (*_info_seq)[_pos]);
   }

   value_type operator ->() const {
     return value_type((*_seq)[_pos], (*_info_seq)[_pos]);
   }

   value_type operator [] (difference_type offset) const {
       return value_type((*_seq)[_pos + offset], (*_info_seq)[_pos + offset]);
   }

   SampleIterator & operator ++ () {
     ++_pos;
     return *this;
   }

   SampleIterator operator ++ (int) {
     SampleIterator temp(*this);
     ++(*this);
     return temp;
   }

   SampleIterator & operator -- () {
     --_pos;
     return *this;
   }

   SampleIterator operator -- (int) {
     SampleIterator temp(*this);
     --(*this);
     return temp;
   }

   SampleIterator & operator -= (difference_type i) {
     _pos -= i;
     return *this;
   }

   SampleIterator & operator += (difference_type i) {
     _pos += i;
     return *this;
   }

   friend SampleIterator operator - (const SampleIterator & si, 
                                     difference_type i) {
     return SampleIterator(*si._seq, *si._info_seq, si._pos - i);
   }

   friend SampleIterator operator + (const SampleIterator & si, 
                                     difference_type i) {
     return SampleIterator(*si._seq, *si._info_seq, si._pos + i);
   }

   friend difference_type operator - (const SampleIterator & s1,
                                      const SampleIterator & s2) {
     return s1._pos - s2._pos;
   }

   friend bool operator < (const SampleIterator & s1,
                           const SampleIterator & s2) {
     return s1._pos < s2._pos;
   }

   friend bool operator > (const SampleIterator & s1,
                           const SampleIterator & s2) {
     return s1._pos > s2._pos;
   }

   friend bool operator <= (const SampleIterator & s1,
                            const SampleIterator & s2) {
     return s1._pos <= s2._pos;
   }

   friend bool operator >= (const SampleIterator & s1,
                            const SampleIterator & s2) {
     return s1._pos >= s2._pos;
   }

   friend bool operator == (const SampleIterator & s1,
                            const SampleIterator & s2) {
     return (s1._seq == s2._seq) && (s1._pos == s2._pos);
   }

   friend bool operator != (const SampleIterator & s1,
                            const SampleIterator & s2) {
     return !(s1 == s2);
   }

   bool is_end() const {
       return ((int) _seq->length()) == _pos;
   }

   // Keep these members public otherwise some of the 
   // converting constructors will not compile.
public:
   TSeq *    _seq;
   InfoSeq * _info_seq;
   int    _pos;
};

template <typename T, bool IsConst>
class ValidSampleIterator
{
public:
   typedef std::forward_iterator_tag iterator_category;

   typedef typename SampleIterator<T, IsConst>::difference_type difference_type;

   typedef typename SampleIterator<T, IsConst>::value_type value_type;

   typedef typename SampleIterator<T, IsConst>::reference reference;
   typedef typename SampleIterator<T, IsConst>::value_type pointer;

   typedef typename SampleIterator<T, IsConst>::Seq Seq;

   typedef typename SampleIterator<T, IsConst>::TSeq TSeq;
   typedef typename SampleIterator<T, IsConst>::InfoSeq InfoSeq;

   ValidSampleIterator() 
    : _it() 
   {}

   template <bool IsConstSampleIter>
   explicit ValidSampleIterator(SampleIterator<T, IsConstSampleIter> related_it)
     : _it(related_it)
   {
       skip_invalid();
   }

   ValidSampleIterator (const ValidSampleIterator<T, false> & other)
     : _it(other.underlying())
   {}

   ValidSampleIterator & operator = (const ValidSampleIterator<T, false> & other)
   {
     _it = other.underlying();
     return *this;
   }

   value_type operator * () const {
     return *_it;
   }

   value_type operator ->() const {
     return *_it;
   }

   ValidSampleIterator & operator ++ () {
       ++_it;
       skip_invalid();
       return *this;
   }

   ValidSampleIterator operator ++ (int) {
       ValidSampleIterator temp(*this);
       ++(*this);
       return temp;
   }

   SampleIterator<T, IsConst> underlying() const {
       return _it;
   }

   friend bool operator < (const ValidSampleIterator & s1,
                           const ValidSampleIterator & s2) {
     return s1._it < s2._it;
   }

   friend bool operator > (const ValidSampleIterator & s1,
                           const ValidSampleIterator & s2) {
     return s1._it > s2._it;
   }

   friend bool operator <= (const ValidSampleIterator & s1,
                            const ValidSampleIterator & s2) {
     return s1._it <= s2._it;
   }

   friend bool operator >= (const ValidSampleIterator & s1,
                            const ValidSampleIterator & s2) {
     return s1._it >= s2._it;
   }

   friend bool operator == (const ValidSampleIterator & s1,
                            const ValidSampleIterator & s2) {
     return s1._it == s2._it;
   }

   friend bool operator != (const ValidSampleIterator & s1,
                            const ValidSampleIterator & s2) {
     return !(s1 == s2);
   }

private:

   void skip_invalid() {
       while (!_it.is_end() && !(_it->info().valid_data)) {
           ++_it;
       }
   }

   SampleIterator<T, IsConst> _it;
};

/**
 * @ingroup PatternsInfrastructureModule
 * @brief Creates an iterator that only returns valid samples
 *
 * This operation returns an iterator adapter that behaves as the associated
 * \idref_SampleIterator expect that it skips samples where
 * <tt>SampleRef::info().valid_data</tt> is false
 *
 * @param related_iterator A regular SampleIterator
 * (e.g. \idref_LoanedContainer_begin) that serves as the start point.
 *
 * @return An iterator pointing to the first valid sample on or after
 * \p related_iterator or the end of the associated \idref_LoanedContainer if
 * there are no valid samples.
 *
 * @see \idref_LoanedContainer_begin
 * @see \ref RequestReplyExampleModule_get_copied_samples
 */
template <typename T, bool IsConst>
ValidSampleIterator<T, IsConst> make_valid_sample_iterator(
    SampleIterator<T, IsConst> related_iterator)
{
    return ValidSampleIterator<T, IsConst>(related_iterator);
}

/**
 * \dref_LoanedContainer
 */
template <typename T>
class LoanedSamples
{
public:
   typedef typename dds_type_traits<T>::Seq                             TSeq;
   typedef typename dds_type_traits<T>::DataReader                      TDataReader;

   /**
    * @brief The iterator type
    */
   typedef SampleIterator<T, false>                                     iterator;

   /**
    * @brief The const iterator type
    */
   typedef SampleIterator<T, true>                                      const_iterator;

   typedef typename dds_type_traits<T>::SampleIteratorValueType         value_type;
   typedef typename dds_type_traits<T>::ConstSampleIteratorValueType    const_value_type;
   typedef std::ptrdiff_t                                               difference_type;

private:

    template <typename U>
    class SequenceMemento 
    {
        char buffer[sizeof(typename dds_type_traits<U>::Seq)];

    public:
        SequenceMemento()
        {
            typename dds_type_traits<U>::Seq default_seq;
            pull_state(default_seq);
        }

        void push_state(typename dds_type_traits<U>::Seq & seq) const throw()
        {
            RTIOsapiMemory_copy(&seq, buffer, sizeof(seq));
        }

        void pull_state(const typename dds_type_traits<U>::Seq & seq) throw()
        {
            RTIOsapiMemory_copy(buffer, &seq, sizeof(seq));
        }
    };

    static bool is_loaning(TSeq & seq) {
        return !seq.has_ownership();
    }

    static bool is_loaning(SampleInfoSeq & seq) {
        return !seq.has_ownership();
    }

    static bool is_default_init(TSeq & seq) {
        return ((seq.length() == 0) && seq.has_ownership());
    }

    static bool is_default_init(SampleInfoSeq & seq) {
        return ((seq.length() == 0) && seq.has_ownership());
    }

    template <typename U>
    static void swap_sequence(typename dds_type_traits<U>::Seq & seq1, 
                              typename dds_type_traits<U>::Seq & seq2)
    {
        SequenceMemento<U> seq1_memento;
        SequenceMemento<U> seq2_memento;

        // read state
        seq1_memento.pull_state(seq1);
        seq2_memento.pull_state(seq2);

        // write swapped state
        seq1_memento.push_state(seq2);
        seq2_memento.push_state(seq1);
    }

    void set_default() // same as the default ctor
    {
        LoanMemento default_loan_memento;

        default_loan_memento._seq_memento.push_state(_seq);
        default_loan_memento._infoseq_memento.push_state(_infoseq);
        _datareader = NULL;
    }

    // Private c-tor only to be used from static method "move_construct_from_loans"
    LoanedSamples(TDataReader * reader, TSeq & data_seq, SampleInfoSeq & info_seq)
        : _datareader(reader)
    {
        swap_sequence<T>(_seq, data_seq);
        swap_sequence<SampleInfo>(_infoseq, info_seq);
    }

    // Direct assignment from one LoanedSamples to another is disabled.
    // Use the move function to assign one LoanedSamples to another.
    LoanedSamples(LoanedSamples &);
    LoanedSamples & operator = (LoanedSamples &);

    TSeq _seq;
    SampleInfoSeq _infoseq;
    TDataReader * _datareader;

public:

   /**
    * @brief A simple value-type for the internal representation of
    *        the a LoanedSamples object.
    *  
    *        Objects of this type can be used to store
    *        LoanedSamples in an STL container. Care be taken in
    *        case of exceptions because LoanMemento does not offer
    *        support for exception-safe programming.
    */
    struct LoanMemento 
    {
        typedef LoanedSamples       Parent;

        SequenceMemento<T>          _seq_memento;
        SequenceMemento<SampleInfo> _infoseq_memento;
        TDataReader * _datareader;
    };

    /**
     * @brief Creates an empty LoanedSamples object.
     */
    LoanedSamples()
     :  _datareader(NULL)
    {
        // same as set_default
    }

    /**
     * @brief Create a new LoanedSamples object by moving the ownership of the data sequence and 
     *        the \idref_SampleInfo sequences.
     *     
     * @pre   The \p data_seq and \p info_seq parameters must contained loaned sample from the same
     *        DataReader.
     *
     * @param reader     The DataReader from which the loan was taken.
     * @param data_seq   The \idref_FooSeq object containing the loaned samples. 
     *                    After the call this sequence will be empty.
     * @param info_seq   The \idref_SampleInfoSeq object containing the loaned SampleInfo.
     *                   After this call the sequence will be empty.
     * @post The new LoanedSamples object will manage the ownership of the loans.
     *
     * @return void
     *
     * @see \idref_LoanedContainer
     */
    static LoanedSamples move_construct_from_loans(TDataReader * reader, 
                                                   TSeq & data_seq, 
                                                   SampleInfoSeq & info_seq)
    {
        const char * METHOD_NAME = "LoanedSamples::move_construct_from_loans";
        if(!reader) {
            check_retcode(DDS_RETCODE_BAD_PARAMETER, 
                          METHOD_NAME,
                          DDS_LOG_BAD_PARAMETER_s, "reader");
        }

        return LoanedSamples(reader, data_seq, info_seq);
    }

    /**
     * @brief Transfers the ownership of the underlying data and the \idref_SampleInfo sequences. 
     *     
     * @pre   The \p data_seq and \p info_seq parameters must be default initialized prior to this call.
     *
     * @param reader_ptr The DataReader from which the loan was taken. After the call the pointer
     *                   will be updated.
     * @param data_seq   The \idref_FooSeq object that will contain the loan previously held by the
     *                   LoanedSamples object. After the call this sequence will loan the underlying data.
     * @param info_seq   The \idref_SampleInfoSeq object that will contain the SampleInfo loan previously
     *                   held by the LoanedSamples object. After this call this sequence will loan the
     *                   underlying \idref_SampleInfoSeq.
     * @post The \p data_seq and \p info_seq objects will contain the loan previously held by the 
     *       LoanedSamples. The LoanedSamples object will release its ownership.
     *
     * @return void
     *
     * @see \idref_LoanedContainer
     */
    void release(TDataReader *& reader_ptr, TSeq & data_seq, SampleInfoSeq & info_seq) 
    {
        const char * METHOD_NAME = "LoanedSamples::release";
        if (!is_default_init(data_seq) ||
            !is_default_init(info_seq)) 
        {
            check_retcode(DDS_RETCODE_PRECONDITION_NOT_MET, METHOD_NAME,
                    RTI_LOG_PRECONDITION_FAILURE_s,
                    "At least one of the sequences is not default initialized");
        }

        reader_ptr = _datareader;
        swap_sequence<T>(_seq, data_seq);
        swap_sequence<SampleInfo>(_infoseq, info_seq);
    }

    /**
     * @brief Reconstruct a new LoanedSamples object from an internal representation of another.
     *     
     *        This constructor will regain the ownership of the underlying data and \idref_SampleInfo
     *        sequences. 
     *
     * @param loan_memento The internal representation of another LoanedSamples object.
     *
     * @see \idref_LoanedContainer
     */
    LoanedSamples(LoanMemento loan_memento) throw()
    {
        loan_memento._seq_memento.push_state(_seq);
        loan_memento._infoseq_memento.push_state(_infoseq);
        _datareader = loan_memento._datareader;
    }

    /*i
     */
    LoanedSamples & operator = (LoanMemento loan_memento) throw()
    {
        // copy-and-swap idiom
        LoanedSamples(loan_memento).swap(*this);
        return *this;
    }

    /**
     * @brief Automatically returns the loan to the middleware
     * @see return_loan
     */
    ~LoanedSamples() throw()
    { 
        return_loan();
    }

    TSeq & data_seq() {
        return _seq;
    }

    SampleInfoSeq & info_seq() {
        return _infoseq;
    }

    const TSeq & data_seq() const {
        return _seq;
    }

    const SampleInfoSeq & info_seq() const {
        return _infoseq;
    }

    /**
     * @brief Provides access to the underlying SampleRef object in array-like syntax.
     *
     * @param index The index of the Sample. Allowed values are from o to length()-1.
     *
     * @return A \idref_SampleRef object that refers to data and \idref_SampleInfo
     *         at the specified \p index.
     *
     * @see \idref_LoanedContainer
     */
    value_type operator [] (size_t index) {
       return value_type(_seq[index], _infoseq[index]);
    }

    /**
     * @brief Provides access to the underlying SampleRef object in array-like syntax.
     *
     * @param index The index of the Sample. Allowed values are from o to length()-1.
     *
     * @return A \idref_SampleRef object that refers to a constant data and constant
     *         \idref_SampleInfo at the specified \p index.
     *
     * @see \idref_LoanedContainer
     */
    const_value_type operator [] (size_t index) const {
       return const_value_type(_seq[index], _infoseq[index]);
    }

    /**
     * \dref_LoanedContainer_length
     */
    int length() const {
        return static_cast<int>(_seq.length());
    }

    void set_datareader(TDataReader * reader) {
        const char * METHOD_NAME = "LoanedSamples::set_datareader";

        if(reader == NULL) {
            check_retcode(DDS_RETCODE_BAD_PARAMETER, METHOD_NAME,
                          DDS_LOG_BAD_PARAMETER_s, "reader");
        }

        _datareader = reader;
    }

    /**
     * \dref_LoanedContainer_return_loan
     */
    void return_loan() {
        if(_datareader) {
            if(is_loaning(_seq) && is_loaning(_infoseq)) {
                _datareader->return_loan(_seq, _infoseq);

                // Clear the internal state.
                set_default();
            }
        }
    }

    void swap(LoanedSamples & that) throw()
    {
        swap_sequence<T>(_seq, that._seq);
        swap_sequence<SampleInfo>(_infoseq, that._infoseq);

        using std::swap;
        swap(_datareader, that._datareader);
    }

    /**
     * @brief Release the ownership of the underlying loaned data and SampleInfo and returns 
     *        an internal representation object.
     *     
     * LoanMemento object has trivial copy semantics. Therefore, it does not manage resources
     * automatically like LoanedSamples does. This conversion function should be used very carefully.
     * This conversion can be used to store LoanedSamples in a standard library containers.
     * However, note that resource management must be handled manually.
     *
     * @see \idref_LoanedContainer
     */
    operator LoanMemento () throw() {
        LoanMemento retval;
        retval._seq_memento.pull_state(_seq);
        retval._infoseq_memento.pull_state(_infoseq);
        retval._datareader = _datareader;

        // Clear the internal state.
        set_default();

        return retval;
    }

    /**
     * \dref_LoanedContainer_begin
     */
    iterator begin() {
        return iterator(_seq, _infoseq, 0);
    }

    /**
     * \dref_LoanedContainer_end
     */
    iterator end() {
        return iterator(_seq, _infoseq, _seq.length());
    }

    /**
     * \dref_LoanedContainer_begin
     */
    const_iterator begin() const {
        return const_iterator(_seq, _infoseq, 0);
    }

    /**
     * \dref_LoanedContainer_end
     */
    const_iterator end() const {
        return const_iterator(_seq, _infoseq, _seq.length());
    }
};

/**
 * @ingroup PatternsInfrastructureModule
 * @brief Creates a new LoanedSamples instance by moving the contents of an existing one. 
 *
 *        The parameter object looses the ownership of the underlying samples and its state 
 *        is reset as if it was default initialized. This function must be used to move 
 *        any named LoanedSamples instance (lvalue) in and out of a function by-value. 
 *        Using this function is not necessary if the original LoanedSamples is an rvalue. 
 *        Moving is a very efficient operation and is guaranteed to not throw any exception.
 *
 * @param ls The LoanedSamples object that transfers its ownership of the contained
 *           samples into the returned object. After this call, \p ls is empty.
 *
 * @return A new LoanedSamples object, the new loan owner,
 *         with the same contents as \p ls had.
 *
 * @see \idref_LoanedContainer
 */
template <typename T>
LoanedSamples<T> move(LoanedSamples<T> & ls) throw()
{
    return LoanedSamples<T>(typename LoanedSamples<T>::LoanMemento(ls));
}

template <typename T>
typename LoanedSamples<T>::iterator begin(LoanedSamples<T> & ls)
{
    return ls.begin();
}

template <typename T>
typename LoanedSamples<T>::const_iterator begin(const LoanedSamples<T> & ls)
{
    return ls.begin();
}

template <typename T>
typename LoanedSamples<T>::iterator end(LoanedSamples<T> & ls)
{
    return ls.end();
}

template <typename T>
typename LoanedSamples<T>::const_iterator end(const LoanedSamples<T> & ls)
{
    return ls.end();
}

template <typename T>
void swap(LoanedSamples<T> &ls1, LoanedSamples<T> &ls2) throw()
{
    ls1.swap(ls2);
}

namespace details {

template <class RefType> // could be SampleRef or WriteSampleRef
void check_nil(RefType & ref)
{
    const char * METHOD_NAME = "check_nil";

    if (ref.is_nil_data()) {
        check_retcode(DDS_RETCODE_BAD_PARAMETER, 
                      METHOD_NAME, 
                      RTI_LOG_ANY_FAILURE_s, 
                      "Data is NULL in the reference type");
    }

    if (ref.is_nil_info()) {
        check_retcode(DDS_RETCODE_BAD_PARAMETER, 
                      METHOD_NAME, 
                      RTI_LOG_ANY_FAILURE_s, 
                      "Info is NULL in the reference type");
    }
}

template<typename T, typename I>
void copy_sample(Sample<T> & sample, const T & data, const I& info)
{
    const char * METHOD_NAME = "copy_sample";
    DDS_ReturnCode_t retcode = 
        dds_type_traits<T>::TypeSupport::copy_data(&sample.data(), &data);

    check_retcode(retcode, METHOD_NAME, RTI_LOG_ANY_FAILURE_s, "copy data");
    sample.set_info(info);
}

template<typename I>
void copy_sample(Sample<char *> & sample, char * data, const I& info)
{
    const char * METHOD_NAME = "copy_sample(char *)";
    DDS_ReturnCode_t retcode = 
        dds_type_traits<char *>::TypeSupport::copy_data(sample.data(), data);

    check_retcode(retcode, METHOD_NAME, RTI_LOG_ANY_FAILURE_s, "copy data");
    sample.info() = info;
}

// Invalid. Can't overwrite const char *
template<typename I>
void copy_sample(Sample<const char *> & sample, const char * data, const I& info); 

template<typename T, typename I>
void copy_sample_ref(SampleRef<T> sample_ref, const T & data, const I& info)
{
    const char * METHOD_NAME = "copy_sample_ref(T)";
    check_nil(sample_ref);

    DDS_ReturnCode_t retcode = 
        dds_type_traits<T>::TypeSupport::copy_data(&sample_ref.data(), &data);

    check_retcode(retcode, METHOD_NAME, RTI_LOG_ANY_FAILURE_s, "copy data");
    sample_ref.info() = info;
}

template<typename I>
void copy_sample_ref(SampleRef<char *> sample_ref, char * data, const I& info)
{
    const char * METHOD_NAME = "copy_sample_ref(char *)";
    check_nil(sample_ref);

    DDS_ReturnCode_t retcode = 
        dds_type_traits<char *>::TypeSupport::copy_data(sample_ref.data(), data);

    check_retcode(retcode, METHOD_NAME, RTI_LOG_ANY_FAILURE_s, "copy data");
    sample_ref.info() = info;
}

// Invalid. Can't overwrite const char *
template<typename I>
void copy_sample_ref(SampleRef<const char *> sample_ref, const char * data, const I& info);



// type_support_adapter solves the lack of consistency between
// a regular FooTypeSupport that can only be treated as a singleton
// and a DynamicDataTypeSupport that has to be instantiated
template <typename T>
class type_support_adapter {
public:
    static const char * register_type(
        DDSTypeSupport * type_support,
        DomainParticipant * participant)
    {
        const char * METHOD_NAME = "type_support_adapter::register_type";

        // type_support ignored -- using singleton
        DDS_ReturnCode_t retcode =
            dds_type_traits<T>::TypeSupport::register_type(
                participant, dds_type_traits<T>::TypeSupport::get_type_name());

        check_retcode(retcode, METHOD_NAME,
                      RTI_LOG_ANY_FAILURE_s, std::string("register type (") +
                      dds_type_traits<T>::TypeSupport::get_type_name() + ")");

        return dds_type_traits<T>::TypeSupport::get_type_name();
    }
};

template <>
class type_support_adapter<DynamicData> {
public:
    static const char * register_type(
        DDSTypeSupport * type_support,
        DomainParticipant * participant)
    {
        const char * METHOD_NAME =
            "type_support_adapter<DynamicData>::register_type";

        if (type_support == NULL) {
            check_retcode(DDS_RETCODE_BAD_PARAMETER, METHOD_NAME,
                          DDS_LOG_BAD_PARAMETER_s,
                          "DynamicData type support required");
        }

        DynamicDataTypeSupport * dd_type_support =
            dynamic_data_type_support_cast(type_support);

        if(!dd_type_support) {
            check_retcode(DDS_RETCODE_BAD_PARAMETER, METHOD_NAME,
                          DDS_LOG_BAD_PARAMETER_s,
                          "bad cast: type_support is not a DDS::DynamicDataTypeSupport");
        }

        DDS_ReturnCode_t retcode = dd_type_support->register_type(
            participant, dd_type_support->get_type_name());

        check_retcode(retcode, METHOD_NAME,
                      RTI_LOG_ANY_FAILURE_s, std::string("register type (") +
                      dd_type_support->get_type_name() + ")");

        return dd_type_support->get_type_name();
    }
};

template <class T>
typename dds_type_traits<T>::LoanedSamplesType 
create_loaned_samples(
    void ** dataPtrArray, 
    int dataCount, 
    SampleInfoSeq & info_seq,
    typename dds_type_traits<T>::DataReader * datareader)
{
   typename dds_type_traits<T>::Seq data_seq;
   typedef typename dds_type_traits<T>::LoanedSamplesType LoanedSamplesType;




    data_seq.loan_discontiguous(
            const_cast<typename remove_const<T **>::type>(
                    reinterpret_cast<T **>(dataPtrArray)),
            dataCount, dataCount);

    return LoanedSamplesType::move_construct_from_loans(
        datareader, data_seq, info_seq);
}

template<>
dds_type_traits<std::string>::LoanedSamplesType
create_loaned_samples<std::string>(
    void ** dataPtrArray, 
    int dataCount, 
    SampleInfoSeq & info_seq,
    dds_type_traits<std::string>::DataReader * datareader);


} // namespace details
} // namespace connext


#endif /* connext_cpp_infrastructure_h */
