/* (c) Copyright 2003-2015, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)transport_tcp_socketutil.h    generated by: makeheader    Fri Feb 16 13:53:12 2018
 *
 *		built from:	socketutil.ifc
 */

#ifndef transport_tcp_socketutil_h
#define transport_tcp_socketutil_h


#ifndef transport_tcp_dll_h
  #include "transport_tcp/transport_tcp_dll.h"
#endif
#ifndef transport_interface_h
  #include "transport/transport_interface.h"
#endif

/* Needed by RTINtpTime */
#ifndef osapi_ntptime_h
  #include "osapi/osapi_ntptime.h"
#endif

/* Needed by REDAFastBufferPoolProperty */
#ifndef reda_fastBuffer_h
  #include "reda/reda_fastBuffer.h"
#endif

#ifdef __cplusplus
    extern "C" {
#endif


#if defined(RTI_WIN32) || defined(RTI_WINCE)
  #define NDDS_TRANSPORT_TCP_SOCKET_CONNECTION_RESET  WSAECONNRESET
#else
  #define NDDS_TRANSPORT_TCP_SOCKET_CONNECTION_RESET ECONNRESET
#endif


#if !defined(RTI_WIN32)

/*i \ingroup NDDS_Transport_TCP_IOCPManager
  @brief In non-WIN32 architectures, NDDS_Transport_TCP_IOCPManager_t is a void
*/

typedef void NDDS_Transport_TCP_IOCPManager_t;

#else

/*****************************************************************************/
/***  IOCP MANAGER INSTANCE                                                ***/
/*****************************************************************************/
/*i \ingroup NDDS_Transport_TCP_IOCPManager
  @brief In WIN32 architectures, NDDS_Transport_TCP_IOCPManager_t is defined by
  struct NDDS_Transport_TCP_IOCPManager
*/

typedef struct NDDS_Transport_TCP_IOCPManager NDDS_Transport_TCP_IOCPManager_t;


/*****************************************************************************/
/***  IOCP MANAGER OVERLAPPED OPERATIONS                                   ***/
/*****************************************************************************/
/*e \ingroup NDDS_Transport_TCP_IOCPManager
  @brief Possible asynchronous operations.
 */

typedef enum NDDS_Transport_TCP_IOCPManagerOverlappedOperation {
    NDDS_TRANSPORT_TCP_IOCP_MANAGER_OP_NONE,
    NDDS_TRANSPORT_TCP_IOCP_MANAGER_OP_ACCEPT,
    NDDS_TRANSPORT_TCP_IOCP_MANAGER_OP_CONNECT,
    NDDS_TRANSPORT_TCP_IOCP_MANAGER_OP_RECVZERO,
    NDDS_TRANSPORT_TCP_IOCP_MANAGER_OP_RECV,
    NDDS_TRANSPORT_TCP_IOCP_MANAGER_OP_SENDZERO,
    NDDS_TRANSPORT_TCP_IOCP_MANAGER_OP_SEND,
    NDDS_TRANSPORT_TCP_IOCP_MANAGER_OP_UNBLOCK
} NDDS_Transport_TCP_IOCPManagerOverlappedOperation;


#define NDDS_Transport_TCP_IOCPManagerOverlappedOperation_toString(type) \
        ((type == NDDS_TRANSPORT_TCP_IOCP_MANAGER_OP_NONE) ? \
                "NONE": \
                ((type == NDDS_TRANSPORT_TCP_IOCP_MANAGER_OP_ACCEPT) ? \
                        "ACCEPT": \
                        ((type == NDDS_TRANSPORT_TCP_IOCP_MANAGER_OP_CONNECT) ? \
                                "CONNECT": \
                                ((type == NDDS_TRANSPORT_TCP_IOCP_MANAGER_OP_RECVZERO) ? \
                                        "RECVZERO" : \
                                        ((type == NDDS_TRANSPORT_TCP_IOCP_MANAGER_OP_RECV) ? \
                                                "RECV" : \
                                                ((type == NDDS_TRANSPORT_TCP_IOCP_MANAGER_OP_SENDZERO) ? \
                                                        "SENDZERO" : \
                                                        ((type == NDDS_TRANSPORT_TCP_IOCP_MANAGER_OP_SEND) ? \
                                                                "SEND" : \
                                                                ((type == NDDS_TRANSPORT_TCP_IOCP_MANAGER_OP_UNBLOCK) ? \
                                                                        "UNBLOCK" : "UNKNOWN"))))))))

/*****************************************************************************/
/***  IOCP MANAGER OVERLAPPED STRUCTURE                                    ***/
/*****************************************************************************/

/*i \ingroup NDDS_Transport_TCP_IOCPManager
  @brief OVERLAPPED structure for issuing an asynchronous operation
 */

struct NDDS_Transport_TCP_IOCPManagerOverlapped
{
    /* This only can be NULL when issuing PostQueuedCompletionStatus to the
     * internal IOCP (currently, only in the delete) */
    OVERLAPPED overlapped;

    /* This contains the IOCP that will receive the completion packet and
     * return the OVERLAPPED structure. If this is set to NULL, the IOCP
     * worker will return the OVERLAPPED structure. */
    HANDLE notificationCompletionPort;

    /* This identifies the operation issued */
    NDDS_Transport_TCP_IOCPManagerOverlappedOperation operation;

    /* This is set by the IOCP worker to the errorCode returned by the
     * asynchronous operation completion. */
    DWORD errorCode;

    /* Socket involved in the asynchronous call */
    SOCKET socket;

    /* This is only used in asynchronous accept calls */
    SOCKET acceptorSocket;

    /* Buffer used for overlapped (asynchronous) send */
    char * sendBuffer;

};


/*****************************************************************************/
/***  IOCP MANAGER PROPERTY                                                ***/
/*****************************************************************************/
/*e \ingroup NDDS_Transport_TCP_IOCPManager
 *
 * @brief Configuration of IOCPManager
 *
 */

struct NDDS_Transport_TCP_IOCPManagerProperty {
    /*e
     * @brief The properties of the overlapped pool.
     *
     * \default REDA_FAST_BUFFER_POOL_PROPERTY_DEFAULT
     */
    struct REDAFastBufferPoolProperty overlappedPoolProperty;

    /*e
     * @brief Maximum number of concurrent workers/threads.     *
     * This determines how many threads can be concurrently processing
     * completion tokens.
     * If numberOfConcurrentWorkers is set to 0, Windows IOCP API will
     * automatically choose the number of concurrent workers.
     *
     * \default 1.
     */
    RTI_UINT32 numberOfConcurrentWorkers;

    /*e
     * @brief Number of workers/threads in the completion pool.     *
     * This determines how many threads will be available for processing
     * completion tokens.
     * If numberOfAvailableWorkers is set to 0, Connext will use a number of
     * threads equal to 2x(number of processors in the system).
     *
     * \default 2.
     */
    RTI_UINT32 numberOfAvailableWorkers;

    /*i
     * @brief The priority for the IOCP threads.
     *
     * \default RTI_OSAPI_THREAD_PRIORITY_DEFAULT.
     */
    RTI_INT32 threadPriority;

    /*i
     * @brief The stack size for the IOCP threads.
     *
     * \default RTI_OSAPI_THREAD_STACK_SIZE_DEFAULT
     */
    RTI_INT32 threadStackSize;

    /*i
     * @brief The pool to use for overlapped send operations.
     * This buffer will be used for getting/returning the buffers the OS needs
     * to complete an asynchronous send.
     * \default NULL
     */
    struct REDAFastBufferPool * sendBufferPool;

};


/*e \ingroup NDDS_Transport_TCP_IOCPManager
 *
 * @brief Default parameters for NDDS_Transport_TCP_IOCPManagerProperty
 *
 */
#define NDDS_TRANSPORT_TCP_IOCP_MANAGER_PROPERTY_DEFAULT { \
        REDA_FAST_BUFFER_POOL_PROPERTY_DEFAULT, \
        1, \
        2, \
        RTI_OSAPI_THREAD_PRIORITY_DEFAULT, \
        RTI_OSAPI_THREAD_STACK_SIZE_DEFAULT, \
        NULL \
}

/*****************************************************************************/
/***  IOCP MANAGER PUBLIC FUNCTIONS                                        ***/
/*****************************************************************************/
/*i \ingroup NDDS_Transport_TCP_IOCPManager
 * Deletes an IOCP Manager.
 */

extern	void NDDS_Transport_TCP_IOCPManager_delete(const struct NDDS_Transport_TCP_IOCPManager *self);


/*i \ingroup NDDS_Transport_TCP_IOCPManager
 * Creates an IOCP Manager.
 */

struct NDDS_Transport_TCP_IOCPManager *
    NDDS_Transport_TCP_IOCPManager_new(
        const char *name,
        const struct NDDS_Transport_TCP_IOCPManagerProperty * property);


/*i \ingroup NDDS_Transport_TCP_IOCPManager
 * @brief This method provides a valid OVERLAPPED structure obtained from the
 * fast buffer pool.
 * This structure already includes the Notification IOCP and the operation
 * to perform.
*/

extern	OVERLAPPED * NDDS_Transport_TCP_IOCPManager_getOverlapped(
    const struct NDDS_Transport_TCP_IOCPManager *self,
    HANDLE notificationCompletionPort,
    NDDS_Transport_TCP_IOCPManagerOverlappedOperation operation);


/*i \ingroup NDDS_Transport_TCP_IOCPManager
 * @brief This method gets a buffer from the send buffer pool and assigns it
 * to the provided OVERLAPPED structure.
 * \return If successful, returns the obtained buffer.
*/

extern	char * NDDS_Transport_TCP_IOCPManager_getOverlappedSendBuffer(
    const struct NDDS_Transport_TCP_IOCPManager *self,
    OVERLAPPED * overlapped);


/*i \ingroup NDDS_Transport_TCP_IOCPManager
 * @brief This method returns the resources consumed by a OVERLAPPED structure
 * to the fast buffer pool.
 * This structure already includes the Notification IOCP and the operation
 * to perform.
*/

extern	RTIBool NDDS_Transport_TCP_IOCPManager_returnOverlapped(
        const struct NDDS_Transport_TCP_IOCPManager *self,
        OVERLAPPED * overlapped);


/*i \ingroup NDDS_Transport_TCP_IOCPManager
 * @brief Closes a notification IOCP.
 *
 * Returns RTI_TRUE if the operation is successful.
*/

extern	RTIBool NDDS_Transport_TCP_IOCPManager_deleteNotificationIocp(
    const struct NDDS_Transport_TCP_IOCPManager *self,
    HANDLE notificationCompletionPort);


/*i \ingroup NDDS_Transport_TCP_IOCPManager
 * @brief Creates a notification IOCP that will receive events from the
 * internal IOCP Manager workers.
 *
 * Returns a HANDLE to the notification completion port  if the operation is
 * successful. If the operation fails, returns NULL.
 *
*/

extern	HANDLE NDDS_Transport_TCP_IOCPManager_createNotificationIocp(
    const struct NDDS_Transport_TCP_IOCPManager *self);


/*i \ingroup NDDS_Transport_TCP_IOCPManager
 * @brief Adds a socket to the IOCP Manager.
 * This allows the workers in the IOCP Manager to react to events in that
 * socket.
 *
 * Note that a socket can be associated to only ONE IOCP. This association
 * remains until the socket is closed. Moreover, if the same socket is passed
 * to this function more than once, the call will fail.
 *
 * Returns RTI_TRUE if the socket has correctly been added to the IOCP Manager.
 *
 */

extern	RTIBool NDDS_Transport_TCP_IOCPManager_addSocket(
    const struct NDDS_Transport_TCP_IOCPManager *self,
    SOCKET sock);


/*i \ingroup NDDS_Transport_TCP_IOCPManager
 * @brief Asserts a socket to the IOCP Manager.
 * This allows the workers in the IOCP Manager to react to events in that
 * socket.
 *
 * Note that a socket can be associated to only ONE IOCP. This association
 * remains until the socket is closed.
 *
 * If the same socket is passed to this function more than once, the call
 * will succeed.
 *
 * Returns RTI_TRUE if the socket has correctly been added to the IOCP Manager
 * or if the socket was already included in the IOCP Manager.
 *
 */

extern	RTIBool NDDS_Transport_TCP_IOCPManager_assertSocket(
    const struct NDDS_Transport_TCP_IOCPManager *self,
    SOCKET sock);


/*i \ingroup NDDS_Transport_TCP_IOCPManager
 * @brief Posts an unblock message that will unblock a thread waiting in a
 * notificationCompletionPort.
 */

extern	RTIBool NDDS_Transport_TCP_IOCPManager_unblockNotificationCompletionPortThread(
        const struct NDDS_Transport_TCP_IOCPManager *self,
        SOCKET sock,
        HANDLE notificationCompletionPort);

#endif


typedef enum  {
    NDDS_TRANSPORT_TCP_SOCKET_GROUP_SOCKET_MONITORING_KIND_WINDOWS_WAITFORMULTIPLEOBJECTS = 0,
    NDDS_TRANSPORT_TCP_SOCKET_GROUP_SOCKET_MONITORING_KIND_SELECT = 1,
    NDDS_TRANSPORT_TCP_SOCKET_GROUP_SOCKET_MONITORING_KIND_WINDOWS_IOCP = 2,
} NDDS_Transport_TCP_SocketGroupSocketMonitoringKind_t;


struct NDDS_Transport_TCP_SocketGroupProperty
{
    /*i @brief Timeout for the wait operation */
    struct RTINtpTime wait_timeout;
    /*i @brief Allows selecting between select, WaitForMultipleObjects, and IOCP in Windows */
    NDDS_Transport_TCP_SocketGroupSocketMonitoringKind_t socket_monitoring_kind;
};


#define NDDS_TRANSPORT_TCP_SOCKET_GROUP_PROPERTY_DEFAULT \
  { \
      RTI_NTP_TIME_MAX, \
      NDDS_TRANSPORT_TCP_SOCKET_GROUP_SOCKET_MONITORING_KIND_SELECT \
  }


typedef int NDDS_Transport_TCP_SocketGroupEventMask;


/*i \ingroup NDDS_TransportTCPSocketGroupComponent
  @brief Socket can be read without blocking

  This option can be used to detect new connections in listen sockets where 
  accept has been called.
  This assumption is NOT true for Windows IOCP.
  Threfore, we introduce the new option
  NDDS_TRANSPORT_TCP_SOCKET_GROUP_SOCKET_READ_FLAG .

  \hideinitializer
*/
#define NDDS_TRANSPORT_TCP_SOCKET_GROUP_SOCKET_READ_FLAG 1

/*i \ingroup NDDS_TransportTCPSocketGroupComponent
  @brief Socket can be written without blocking

  \hideinitializer
*/
#define NDDS_TRANSPORT_TCP_SOCKET_GROUP_SOCKET_WRITE_FLAG 2

/*i \ingroup NDDS_TransportTCPSocketGroupComponent
  @brief Socket in error state.

  \hideinitializer
*/
#define NDDS_TRANSPORT_TCP_SOCKET_GROUP_SOCKET_ERROR_FLAG 4

/*i \ingroup NDDS_TransportTCPSocketGroupComponent
  @brief Socket has been closed by peer.

  \hideinitializer
*/
#define NDDS_TRANSPORT_TCP_SOCKET_GROUP_SOCKET_HANGUP_FLAG 8

/*i \ingroup NDDS_TransportTCPSocketGroupComponent
  @brief Socket descriptor is no longer valid

  \hideinitializer
*/
#define NDDS_TRANSPORT_TCP_SOCKET_GROUP_SOCKET_INVALID_FLAG 16

/*i \ingroup NDDS_TransportTCPSocketGroupComponent
  @brief Socket is LISTENING for new connections.

  \hideinitializer
*/
#define NDDS_TRANSPORT_TCP_SOCKET_GROUP_SOCKET_LISTEN_FLAG 32


struct NDDS_Transport_TCP_SocketGroup;


#if defined(RTI_WIN32)
/* \ingroup NDDS_TransportTCPSocketGroupComponent
  @brief Get the last accepted socket in the socket group.
*/

extern	SOCKET NDDS_Transport_TCP_SocketGroup_getLastAcceptedSocket(
        struct NDDS_Transport_TCP_SocketGroup * self);


/* \ingroup NDDS_TransportTCPSocketGroupComponent
  @brief Get an OVERLAPPED structure for issuing an overlapped operation which
  completion has to be notified to this SocketGroup.
 */

extern	OVERLAPPED * NDDS_Transport_TCP_SocketGroup_getOverlapped(
        struct NDDS_Transport_TCP_SocketGroup * self,
        SOCKET sock,
        NDDS_Transport_TCP_IOCPManagerOverlappedOperation operation);


/* \ingroup NDDS_TransportTCPSocketGroupComponent
  @brief Get the buffer for a given  OVERLAPPED structure.
 */
char * NDDS_Transport_TCP_SocketGroup_getOverlappedSendBuffer(
        struct NDDS_Transport_TCP_SocketGroup * self,
        OVERLAPPED * lpOverlapped);

/*i \ingroup NDDS_TransportTCPSocketGroupComponent
 * @brief Issues a zero send to the specified socket.
 * This allows the workers in the threadArray to react to the availability of
 * the socket for writing. Then the workers will send a notification to the
 * notificationCompletionPort of the SocketGroup.
 */

extern	DWORD NDDS_Transport_TCP_SocketGroup_sendZero(
        const struct NDDS_Transport_TCP_SocketGroup *self,
        SOCKET sock);

#endif

extern NDDS_Transport_TCP_DllExport 
struct NDDS_Transport_TCP_SocketGroup*
NDDS_Transport_TCP_SocketGroup_new(
    const char *name, 
    int id_port,
    const struct NDDS_Transport_TCP_SocketGroupProperty * property,
    const NDDS_Transport_TCP_IOCPManager_t * iocpManager);

extern NDDS_Transport_TCP_DllExport 
void NDDS_Transport_TCP_SocketGroup_delete(struct NDDS_Transport_TCP_SocketGroup *self);

extern NDDS_Transport_TCP_DllExport 
RTIBool NDDS_Transport_TCP_SocketGroup_unblock(struct NDDS_Transport_TCP_SocketGroup *self);


extern	RTI_UINT32 NDDS_Transport_TCP_SocketGroup_getSize(
    struct NDDS_Transport_TCP_SocketGroup *self);


extern	void * NDDS_Transport_TCP_SocketGroup_getFirstSocketData(
        struct NDDS_Transport_TCP_SocketGroup * self);

extern NDDS_Transport_TCP_DllExport 
RTIBool NDDS_Transport_TCP_SocketGroup_add_socket(
    struct NDDS_Transport_TCP_SocketGroup *self, 
    int sock, 
    NDDS_Transport_TCP_SocketGroupEventMask events,
    void * user_data);

extern NDDS_Transport_TCP_DllExport 
RTIBool NDDS_Transport_TCP_SocketGroup_modify_socket(
    struct NDDS_Transport_TCP_SocketGroup *self, 
    int sock, 
    NDDS_Transport_TCP_SocketGroupEventMask events,
    void *data);

extern NDDS_Transport_TCP_DllExport 
RTIBool NDDS_Transport_TCP_SocketGroup_remove_socket(
    struct NDDS_Transport_TCP_SocketGroup *self, unsigned int * waitingEpoch, int sock);

extern NDDS_Transport_TCP_DllExport 
int NDDS_Transport_TCP_SocketGroup_wait(
    struct NDDS_Transport_TCP_SocketGroup *self, 
    int * sock_out, 
    NDDS_Transport_TCP_SocketGroupEventMask * events, 
    void ** user_data);

extern NDDS_Transport_TCP_DllExport
unsigned int NDDS_Transport_TCP_SocketGroup_getWaitingEpoch(
        struct NDDS_Transport_TCP_SocketGroup * self);


#ifdef __cplusplus
    }	/* extern "C" */
#endif

#endif /* transport_tcp_socketutil_h */
