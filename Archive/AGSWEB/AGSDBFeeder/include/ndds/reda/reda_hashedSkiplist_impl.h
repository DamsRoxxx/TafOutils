/* (c) Copyright 2003-2015, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)reda_hashedSkiplist_impl.h    generated by: makeheader    Fri Feb 16 13:51:16 2018
 *
 *		built from:	hashedSkiplist_impl.ifc
 */

#ifndef reda_hashedSkiplist_impl_h
#define reda_hashedSkiplist_impl_h


#ifdef __cplusplus
    extern "C" {
#endif

 
struct REDAHashedSkiplist {
    /* the underlying skiplists */
    struct REDASkiplist **_bucket;
    /*i The hash used */
    struct REDAHashDefinition _hashDefinition;
    /*i Total number of nodes */
    int _nodeCount;
};



  #define REDAHashedSkiplist_gotoTopNodeMacro(self, node) \
	REDASkiplist_gotoTopNodeMacro((self)->_bucket[0], node)

  /* a private method that can be called from a macro; so we need
     to declare it here */
    REDADllExport RTIBool
    REDAHashedSkiplist_gotoFirstNodeInNextBucketInternal(
	struct REDAHashedSkiplist *self,
	const struct REDASkiplistNode **node);

  /*
   * This macro iterates to the next node in the list. It is implemented in
   * such a way that the common case (going to the following node in the same
   * bucket) is very fast; in case we need to skip buckets, we call a
   * function as that is less common.
   *
   * CORE-6928: There was a race condition between the checking of the value of
   * *(node)->forward and its copy to *(node). This race condition may have
   * provoked this macro to incorrectly return RTI_TRUE upon not finding a node.
   * In order to fix this issue we now do the following:
   *   - If *(node)->forward is NULL, we check the next bucket as usual (logic
   *     has not changed for this case).
   *   - If *(node)->forward is not NULL, we copy its value to *(node) and
   *     THEN we RECHECK that the resulting value of *(node) is not NULL -as a
   *     result of the race condition- and we return the result of this check.
   *
   * Note that this macro has a trade off between correctness and performance/
   * complexity/memory usage. This macro ENSURES that the return value is always
   * consistent with the value of *(node), but IT DOES NOT ENSURE that we will
   * not skip node buckets if the list is changes during this macro call. As a
   * consequence, we may report there is no next node even if there are nodes in
   * a different bucket.
   *
   * If you need to make sure no buckets are skipped even if the list changes
   * during this macro call, use REDAHashedSkiplist_gotoNextNodeSafeMacro
   * instead.
   */
  #define REDAHashedSkiplist_gotoNextNodeMacro(self, node) \
    ( (*(node))->forward ? \
      ( (*(node) = (*(node))->forward) != NULL ? RTI_TRUE : RTI_FALSE) : \
      REDAHashedSkiplist_gotoFirstNodeInNextBucketInternal(self, node) )

  /* CORE-6928: This macro is similar to gotoNextNodeMacro, but it uses
   * bucketNode to iterate to the next node bucket when we reach the end of the
   * current bucket. This ensures both that the returned value will always be
   * consistent with the final state of *(node) AND also that we will be able
   * to reach the next bucket even if the value of (*(node))->forward) changes
   * during the macro call.
   *
   * Note that this macro, and also gotoFirstNodeInNextBucketInternal use node
   * as an in/out parameter. Therefore, we need to copy *(bucketNode)
   * -which is just a pointer- to *(node) before calling to
   * gotoFirstNodeInNextBucketInternal.
   */
  #define REDAHashedSkiplist_gotoNextNodeSafeMacro(self, node, bucketNode) \
    ( (*(node) = (*(node))->forward) != NULL ? RTI_TRUE : \
      ( (*(node) = *(bucketNode)), \
      REDAHashedSkiplist_gotoFirstNodeInNextBucketInternal(self, node)) )

  #define REDAHashedSkiplist_getNodeCountMacro(self) ((self)->_nodeCount)

  #define REDAHashedSkiplist_computeBucketIndexMacro(self, key) \
    REDAHash_computeHash(&((self)->_hashDefinition), key)

  #define REDAHashedSkiplist_findNodeMacro(self, answer, preciseMatch, \
                                           searchKey) \
    REDASkiplist_findNodeFastMacro( \
	(self)->_bucket[REDAHashedSkiplist_computeBucketIndexMacro(self, \
                                                                   searchKey)], \
        answer, preciseMatch, searchKey)

  #ifndef RTI_PRECONDITION_TEST

    #define REDAHashedSkiplist_gotoTopNode   REDAHashedSkiplist_gotoTopNodeMacro
    #define REDAHashedSkiplist_gotoNextNode  REDAHashedSkiplist_gotoNextNodeMacro
    #define REDAHashedSkiplist_getNodeCount  REDAHashedSkiplist_getNodeCountMacro
    #define REDAHashedSkiplist_findNode      REDAHashedSkiplist_findNodeMacro

  #endif /* !RTI_PRECONDITION_TEST */



#ifdef __cplusplus
    }	/* extern "C" */
#endif

#endif /* reda_hashedSkiplist_impl_h */
