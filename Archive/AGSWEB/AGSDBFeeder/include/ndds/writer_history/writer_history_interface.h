/* (c) Copyright 2003-2015, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)writer_history_interface.h    generated by: makeheader    Fri Feb 16 13:51:41 2018
 *
 *		built from:	interface.ifc
 */

#ifndef writer_history_interface_h
#define writer_history_interface_h



#ifndef writer_history_dll_h
#include "writer_history/writer_history_dll.h"
#endif

#ifndef osapi_ntptime_h
#include "osapi/osapi_ntptime.h"
#endif

#ifndef osapi_type_h
#include "osapi/osapi_type.h"
#endif

#ifndef reda_fastBuffer_h
#include "reda/reda_fastBuffer.h"
#endif

#ifndef mig_generator_h
#include "mig/mig_generator.h"
#endif

#ifndef commend_writerService_h
#include "commend/commend_writerService.h"
#endif

#ifndef commend_facade_h
    #include "commend/commend_facade.h"
  #endif
#ifdef __cplusplus
    extern "C" {
#endif


struct NDDS_WriterHistory_Plugin;

struct NDDS_WriterHistory_Listener;

typedef enum {
    /*e
      Keep just the last value.
    */
    NDDS_WRITERHISTORY_KEEP_LAST_HISTORY_QOS,

    /*e
      Keep all values.
    */
    NDDS_WRITERHISTORY_KEEP_ALL_HISTORY_QOS
} NDDS_WriterHistory_HistoryQosPolicyKind;

typedef enum {
    /*e
      Volatile.
    */
    NDDS_WRITERHISTORY_VOLATILE_DURABILITY_QOS,

    /*e
      Transient Local.
    */
    NDDS_WRITERHISTORY_TRANSIENT_LOCAL_DURABILITY_QOS,

    /*e
      Transient.
    */
    NDDS_WRITERHISTORY_TRANSIENT_DURABILITY_QOS,

    /*e
      Persistent.
    */
    NDDS_WRITERHISTORY_PERSISTENT_DURABILITY_QOS
} NDDS_WriterHistory_DurabilityQosPolicyKind;


#define NDDS_WRITERHISTORY_INFINITE_DURATION RTI_NTP_TIME_MAX

struct NDDS_WriterHistory_BufferProperty {
    /*e
      The buffer size.
    */
    RTI_UINT32 size;
    /*e
      The buffer alignment.
    */
    RTI_UINT32 alignment;
};


#define NDDS_WRITERHISTORY_LENGTH_UNLIMITED 0

typedef enum {
    /*e
     * Order by reception timestamp.
     */
    WH_BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS,

    /*e
     * Order by source timestamp.
     */
    WH_BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS
} WHDestinationOrderQosPolicyKind;

typedef enum {
    WH_INSTANCE_SCOPE_DESTINATIONORDER_QOS,
    WH_TOPIC_SCOPE_DESTINATIONORDER_QOS
} WHDestinationOrderQosPolicyScopeKind;

typedef enum {
    /*e
     * Scope spans a single instance.
     */
    WH_INSTANCE_ACCESS_SCOPE_PRESENTATION_QOS,

    /*e
     * Scope spans to all instances within the same endpoint.
     */
    WH_TOPIC_ACCESS_SCOPE_PRESENTATION_QOS,

    /*e
     * Scope spans to all instances belong to all writers within the same publisher.
     */
    WH_GROUP_ACCESS_SCOPE_PRESENTATION_QOS
} WHPresentationQosPolicyAccessScopeKind;

typedef enum {
    /*e
     * Immediate mode.
     * Gets when sample inserted into writer queue.
     * Returns when sample sent on wire.
     */
    WH_SERIALIZATION_BUFFER_ALLOC_MODE_IMMEDIATE,

    /*e
     * Lazy mode.
     * Gets when needed (e.g. on resend).
     * Returns when sample removed from writer queue.
     */
    WH_SERIALIZATION_BUFFER_ALLOC_MODE_LAZY

} WHSerializationBufferAllocMode;

struct NDDS_WriterHistory_EncapsulationInfo {
    RTIEncapsulationId encapsulationId;
    WHSerializationBufferAllocMode getMode;
    WHSerializationBufferAllocMode returnMode;
    RTIBool useZeroCopy;
};

struct NDDS_WriterHistory_EndpointGroup {
    /*i
        @brief Role name.
    */
    char * roleName;
    /*i
        @brief Quorum count.
    */
    int quorumCount;
};


#define WH_ENCAPSULATION_INFO_DEFAULT \
{ \
   RTI_CDR_ENCAPSULATION_ID_CDR_NATIVE, /* encapsulationId */ \
   WH_SERIALIZATION_BUFFER_ALLOC_MODE_IMMEDIATE, /* getMode */ \
   WH_SERIALIZATION_BUFFER_ALLOC_MODE_LAZY, /* returnMode */ \
   RTI_FALSE, /* doZeroCopy */ \
}

typedef enum {

    WH_UNREGISTERED_INSTANCE_REPLACEMENT,

    WH_ALIVE_INSTANCE_REPLACEMENT,

    WH_DISPOSED_INSTANCE_REPLACEMENT,

    WH_ALIVE_THEN_DISPOSED_INSTANCE_REPLACEMENT,

    WH_DISPOSED_THEN_ALIVE_INSTANCE_REPLACEMENT,

    WH_ALIVE_OR_DISPOSED_INSTANCE_REPLACEMENT

} NDDS_WriterHistory_InstanceReplacementKind;

typedef enum {

    WH_PROTOCOL_ACK_MODE,

    WH_AUTO_APP_ACK_MODE,

    WH_ORDERED_APP_ACK_MODE,

    WH_EXPLICIT_APP_ACK_MODE

} NDDS_WriterHistory_AckMode;

struct NDDS_WriterHistory_Property {
    /*e
      \brief This property indicates whether or not the WH is going to contain a single instance.

      That instance will be registered only once and it cannot be unregistered or disposed.

      This parameter property has been introduced for optimization purposes.
      A specific implementation of the writer history plugin can take advantage of it.
    */
    RTIBool singleInstance;
    /*e
      \brief Control growth in number of samples (not end coherent changes).

      The value of this property is obtained from DDS_ResourceLimitsQosPolicy.maxSamples
      and DDS_ResourceLimitsQosPolicy.initialSamples.
    */
    struct REDAFastBufferPoolGrowthProperty sampleCount;
    /*e
      \brief Control growth in number of instances.

      The value of this property is obtained from the QoS
      DDS_ResourceLimitsQosPolicy.maxInstances and DDS_ResourceLimitsQosPolicy.initialInstances.

      If the topic associated to the data writer is unkeyed, instanceCount.maximal
      should be 1 to take advantages of optimizations in the implementation.
    */
    struct REDAFastBufferPoolGrowthProperty instanceCount;
    /*e
      \brief The maximum allowable number of samples (without including end coherent changes)
      per instance. The value of this property is obtained from the QoS
      DDS_ResourceLimitsQosPolicy.max_samples_per_instance.
    */
    RTI_INT32 maximalSamplePerInstanceCount;
    /*e
     \brief The instance hash buckets
    */
    RTI_INT32 instanceHashBuckets;
    /*e
      \brief Whether or not a sample should be made automatically reclaimable
      when is added to the WH.
    */
    RTIBool autoReclaimableOnAdd;
	/*e
      \brief Control growth in number of durable subscriptions.

      The value of this property is obtained from the QoS
      TO_BE_DEFINED.tobedefinded

      It determins the max number of durable subscriptions
    */
    struct REDAFastBufferPoolGrowthProperty durableSubscriptionCount;
	/*e
      \brief Sacrifice non reclaimable samples.

      If there are not enough resource limits to satisfy the history depth
      when the history kind is KEEP_LAST but there are at least enough to
      satisfy a history depth of 1, the value denotes whether to sacrifice
      non reclaimable samples by dropping all but the last non reclaimable
      sample of an instance if necessary in order to avoid blocking. */
    RTIBool sacrificeSamples;
    /*e
      \brief The deadline period
    */
    struct RTINtpTime deadlinePeriod;
    /*e
      \brief History kind.
    */
    NDDS_WriterHistory_HistoryQosPolicyKind historyKind;
    /*e
      \brief How many values to keep in the instance history.
    */
    RTI_INT32 historyDepth;
    /*e
      \brief The durability kind.
    */
    NDDS_WriterHistory_DurabilityQosPolicyKind durabilityKind;
    /*e
      \brief The lifespan duration.
      Maximum duration of validity of the data written by DataWriter
    */
    struct RTINtpTime lifespanDuration;
    /*e
      \brief Maximum size and alignment of the buffer used to store the sample inline QoS.
    */
    struct NDDS_WriterHistory_BufferProperty sampleInlineQosDataSize;
    /*e
      \brief Duration for which a sample is delayed from being considered
      acknowledged.
    */
    struct RTINtpTime minSampleKeepDuration;
    struct RTINtpTime maxSampleKeepDuration;
    RTIBool enableAdaptiveKeepDuration;
    struct RTINtpTime sampleKeepDurationMinSeparation;

    /*--- Support for Sessions/Batches ----*/

    /*e
      Number of sessions

      A WH will maintain a single or multiple sessions.

      The samples in a session will be called session samples.

      There is a one to many relationship between a user sample added to the WH
      and the corresponding session samples.
    */
    RTI_UINT32 numberOfSessions;
    /*e
      Number of Non-Cacheable Sessions (Non-Keyed)
    */
    int nonCacheableSessionCount;
    /*e
      Array containing the session Ids for Non-Cacheable Sessions (Non-Keyed)
    */
    RTI_INT32 * nonCacheableSessionIds;

    /*e
     * Enables the capability of republishing samples (entries) that already
     * belong to a session. Creates a dedicated session where to assign the
     * these samples.
     *
     * When republishing a sample, the entry and the serialized user data is
     * shared and only a new session sample is created
     *
     * If enableHistoricalSession is true, numberOfSessions refers to the rest
     * of sessions, not including this one.
     */
    RTIBool enableHistoricalSession;

    /*e
      \brief Indicates if batching is enabled or not
    */
    RTIBool batchEnabled;
    /*e
      \brief Maximum size an alignment of the buffer used to store the batch user data
      (serialize samples)
    */
    struct NDDS_WriterHistory_BufferProperty batchDataSize;
    /*e
      \brief Maximum number of samples in a batch

      If batchSampleCount is NDDS_WRITERHISTORY_LENGTH_UNLIMITED zero,
      the value will not be used by the writer history to do flushing
    */
    RTI_UINT32 batchSampleCount;
    /*e
      \brief Maximum size an alignment of the buffer used to store the batch meta data.
      The meta data is the cumulative length of the serialized sample info attached
      to each one of the batch samples
    */
    struct NDDS_WriterHistory_BufferProperty batchMetaDataSize;
    /*e
      \brief Control growth in number of batches.

      batchesCount.maximal will be ignored.

      The maximum number of batches will always be limited by the maximum number
      of samples.
    */
    struct REDAFastBufferPoolGrowthProperty batchesCount;

    WHDestinationOrderQosPolicyKind destOrderKind;
    WHDestinationOrderQosPolicyScopeKind destOrderScope;
    struct RTINtpTime destOrderTolerance;

    /*--- Support for Multiencapsulation ----*/

    /*e
     \brief Number of encapsulations
    */
    RTI_UINT32 encapsulationCount;
    /*e
      \brief Encapsulation Info
    */
    struct RTIEncapsulationInfo * encapsulationInfo;
    /*e
      \brief Maximum size and alignment of the buffer used to store the
      serialized sample. There is one buffer per encapsulation.
    */
    struct NDDS_WriterHistory_BufferProperty * sampleUserDataSize;
    /*e
      \brief Maximum size and alignment of the buffer used to store the
      serialized key. There is one buffer per encapsulation.
    */
    struct NDDS_WriterHistory_BufferProperty * instanceKeyDataSize;
    int instanceKeyDataAllocThreshold;
    
    /*e
      \brief Cookie maximum size.
    */
    RTI_INT32 cookieBufferMaxSize;

    NDDS_WriterHistory_InstanceReplacementKind instanceReplacementPolicy;
    RTIBool replaceEmptyInstances;
    RTIBool supportsAppAck;
    RTIBool supportsRequiredSubscriptions;
    RTIBool supportsCollabReliability;
    RTIBool keepReaderAckState;
    struct REDASequenceNumber initialVirtualSequenceNumber;

    int maxAppAckReaderCount;
    int maxRemoteReaderCount;

    /*e
      \brief Control growth in number of virtual writers. */
    struct REDAFastBufferPoolGrowthProperty virtualWriterCount;
    WHPresentationQosPolicyAccessScopeKind presentationAccessScopeKind;

    /*e
      \brief The autopurge unregistered samples delay.
      Maximum duration for which the DataWriter will maintain samples for an
      instance once it has been unregistered.
    */
    struct RTINtpTime autopurgeUnregisteredInstancesDelay;

    /*e
      \brief The autopurge disposed samples delay.
      Maximum duration for which the DataWriter will maintain samples for an
      instance once it has been disposed.

      Note: currently only INFINITE (disabled) or ZERO (immediate) are supported
    */
    struct RTINtpTime autopurgeDisposedInstancesDelay;

    /*e
      \brief The maximum number of remote readers to filter for.
     */
    RTI_UINT32 maxRemoteReaderFilters;

    /*e
      \brief The saveFilterStatusInEntry property determines whether or not
     * the filer status shall be saved in a queue entry, regardless of the
     * value of maxRemoteReaderFilters. If this value is true, the filter
     * status is stored only if maxRemoteReaderFilters is finite. When
     * maxRemoteReaderFilters is finite, the status is only stored if this
     * value is true.
     */
    RTIBool storeFilterStatus;

    /*e
      \brief The serialized key material for the writer. The writer history may
     * need to keep the key material as part of the metadata of the writer that
     * needs to be restored later. This way, readers can get the correct key
     * that was used to encode the serialized data. See SEC-248. The writer
     * history implementation cannot modify or keep a reference to this buffer
     * after it is constructed.
     */
    struct REDABuffer cryptoTokens;
};


#define WRITER_HISTORY_PROPERTY_DEFAULT { \
    RTI_TRUE, /* singleInstance */ \
    /* sampleCount */ \
    {32, REDA_FAST_BUFFER_POOL_UNLIMITED, REDA_FAST_BUFFER_POOL_UNLIMITED}, \
    /* instanceCount */ \
    {8, REDA_FAST_BUFFER_POOL_UNLIMITED, REDA_FAST_BUFFER_POOL_UNLIMITED}, \
    -1,  /* maximalSamplePerInstanceCount: unlimited */     \
    1, /* instanceHashBuckets */ \
    RTI_FALSE, /* autoReclaimableOnAdd */ \
    /*durableSubscriptionCount*/ \
    {8, REDA_FAST_BUFFER_POOL_UNLIMITED, REDA_FAST_BUFFER_POOL_UNLIMITED}, \
    RTI_FALSE, /* sacrificeSamples */ \
    RTI_NTP_TIME_MAX, /* deadlinePeriod */ \
    NDDS_WRITERHISTORY_KEEP_ALL_HISTORY_QOS, /* historyKind */ \
    0, /* historyDepth - irrelevent with keep all */ \
    NDDS_WRITERHISTORY_TRANSIENT_LOCAL_DURABILITY_QOS, /* durabilityKind */ \
    RTI_NTP_TIME_MAX, /* lifespanDuration */ \
    {0, 1}, /* sampleInlineQosDataSize */ \
    RTI_NTP_TIME_MAX, /* minSampleKeepDuration */ \
    RTI_NTP_TIME_MAX, /* maxSampleKeepDuration */ \
    RTI_FALSE, \
    RTI_NTP_TIME_MAX, /* sampleKeepDurationMinSeparation */ \
    1,  /* numberOfSessions */ \
    0,  /* nonCacheableSessionCount */ \
    NULL, /* nonCacheableSessionIds */ \
    RTI_FALSE, /* enableHistoricalSession */ \
    RTI_FALSE, /* batchEnabled */ \
    {0, 1}, /* batchDataSize */ \
    0, /* batchSampleCount */ \
    {0, 1}, /* batchMetaDataSize */ \
    /* batchesCount */ \
    {1, REDA_FAST_BUFFER_POOL_UNLIMITED, REDA_FAST_BUFFER_POOL_UNLIMITED}, \
    WH_BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS, /* destOrderKind */ \
    WH_INSTANCE_SCOPE_DESTINATIONORDER_QOS, /* destOrderScope */ \
    RTI_NTP_TIME_MAX, /* destOrderTolerance */ \
    0, /* encapsulationCount */ \
    NULL, /* encapsulationInfo */ \
    NULL, /* sampleUserDataSize */ \
    NULL, /* instanceKeyDataSize */ \
    REDA_FAST_BUFFER_POOL_UNLIMITED, /* instanceKeyDataAllocThreshold */ \
    128, /* cookieBufferLength */ \
    WH_UNREGISTERED_INSTANCE_REPLACEMENT, /* instanceReplacementPolicy */ \
    RTI_FALSE, /* replaceEmptyInstances */ \
    RTI_FALSE, /* supportsAppAck */ \
    RTI_FALSE, /* supportsRequiredSubscriptions */ \
    RTI_FALSE, /* supportsCollabReliability */ \
    RTI_TRUE, /* keepReaderAckState */ \
    REDA_SEQUENCE_NUMBER_AUTO, /* initial_virtual_sequence_number */ \
    -1, /* maxAppAckReaderCount: unlimited */ \
    -1, /* maxRemoteReaderCount: unlimited */ \
    /* virtualWriterCount */ \
    {1, REDA_FAST_BUFFER_POOL_UNLIMITED, REDA_FAST_BUFFER_POOL_UNLIMITED}, \
    WH_TOPIC_ACCESS_SCOPE_PRESENTATION_QOS, \
    RTI_NTP_TIME_MAX, /* autopurgeUnregisteredInstancesDelay */ \
    RTI_NTP_TIME_MAX, /* autopurgeDisposedInstancesDelay */ \
    32UL, /* maxRemoteReaderFilters */\
    RTI_TRUE, /* storeFilterStatus */\
    REDA_BUFFER_INVALID /* cryptoTokens */\
}

extern WRITERHISTORYDllExport
void NDDS_WriterHistory_Property_initialize(struct NDDS_WriterHistory_Property * self);

extern WRITERHISTORYDllExport
void NDDS_WriterHistory_Property_finalize(struct NDDS_WriterHistory_Property * self);

extern WRITERHISTORYDllExport
void NDDS_WriterHistory_Property_copy(struct NDDS_WriterHistory_Property * to,
                                      const struct NDDS_WriterHistory_Property * src);

typedef enum {
    /*e
      Data sample.
    */
    NDDS_WRITERHISTORY_DATA_SAMPLE = 0x00,
    /*e
      Unregister sample.
    */
    NDDS_WRITERHISTORY_UNREGISTER_SAMPLE = 0x01,
    /*e
      Dispose sample.
    */
    NDDS_WRITERHISTORY_DISPOSE_SAMPLE = 0x02,
    /*e
      Unregister/Dispose sample.
    */
    NDDS_WRITERHISTORY_UNREGISTER_DISPOSE_SAMPLE = 0x03,
    /*e
      End coherency sample.
    */
    NDDS_WRITERHISTORY_END_COHERENCY_SAMPLE  = 0x04,
    /*e
      Batch sample
    */
    NDDS_WRITERHISTORY_BATCH_SAMPLE = 0x05
} NDDS_WriterHistory_SampleKind;

struct NDDS_WriterHistory_BatchStatus {
    /*e
      \brief Last sample sequence number in a batch
      This field is used in batches
    */
    struct REDASequenceNumber lastSnInBatch;
    /*i
      data encapsulation kind identifier
    */
    RTI_UINT16 *batchEncapsulationKind; /* multi-encapsulation array */
    /*i
      data encapsulation options of specific kind
    */
    RTI_UINT16 batchEncapsulationOptions;
};

struct NDDS_WriterHistory_Instance {
    /*e
        \brief Instance key hash.
    */
    struct MIGRtpsKeyHash keyHash;
    struct REDABuffer keyData;
    /*e
      \brief Serialized key array. There is one element per encapsulation
      With only one encapsulation serializedKeyArray points to &keyData.
    */
    struct REDABuffer * keyDataArray;
    /*e
      \brief Status of the instance.
    */
    RTIBool registered;
    /*e
      Number of (cached) sessions (passing evaluation) associated to the instance
    */
    RTI_UINT32 cachedSessionCount;
    /*e
      Array containing the (cached) session Ids associated with the instance
      (as a result of passing evaluation)
    */
    RTI_INT32 * cachedSessionIds;
    /*e
      An inline list containing weak references to records in the pres filtered writer
      remote reader table. This list only considers readers that have key only filters
      specified.
    */
    struct REDAInlineList keyOnlyFilteredReadersList;
    /*e
      Epoch to identify if the list of key only filtered readers is dirty or not.
      A instance is considered dirty if the epoch of the instance does not match
      the epoch in the writer. The epoch will be updated when the keyOnlyFilteredReadersList
      is recreated.
    */
    REDAEpoch epoch;
    /*e
     * The last source timestamp when this instance was updated.
     */
    struct RTINtpTime lastSourceTimestamp;
};

struct NDDS_WriterHistory_Sample {
    /*e
       \brief RTI DDS sample.
       This must be the first element.
    */
    struct MIGGeneratorSample sample;
    /*e
      \brief Kind of sample.
    */
    NDDS_WriterHistory_SampleKind kind;
    /*e
      \brief Filter status.
    */
    struct COMMENDFilterStatus filterStatus;
    /*e
      \brief Batch Status
    */
    struct NDDS_WriterHistory_BatchStatus * batchStatus;
    /* e
      \brief Instance associated with the sample
    */
    struct NDDS_WriterHistory_Instance * instance;
};

struct NDDS_WriterHistory_BatchSampleGroup {
    struct REDAInlineListNode node;
    NDDS_WriterHistory_SampleKind kind;
    RTI_INT32 numberOfSamples;
    struct MIGRtpsKeyHash instanceKeyHash;
    struct REDABuffer serializedKey;
    /* With only one encapsulation serializedKeyArray points to
       &serializedKey */
    struct REDABuffer * serializedKeyArray;
    /* Timestamps per sample */
    /* This member is only used when the timestamp resolution
    is different than INFINITE */
    struct RTINtpTime * timestamps;
    /* This member is an array of the originalWriterInfo*/
    struct NDDS_WriterHistory_OriginalWriterInfo *originalWriterInfos;
    /* Session information*/
    /* Every sample in a group must go to the same session */
    RTI_UINT32 sessionCount;
    RTI_INT32 singleSessionId; /* For optimizations puposes */
    RTI_INT32 * sessionId;
    struct REDABuffer singleGroupSampleInfo; /* For optimizations puposes */
    struct REDABuffer * groupSampleInfo;
};

typedef void * NDDS_WriterHistory_Handle;

struct WriterHistory_IeeeTime {
    /*e Seconds */
    RTI_INT32 sec;
    /*e Nano seconds */
    RTI_UINT32 nanosec;
};

struct NDDS_WriterHistory_MetaData {
    /*e
      Publication priority of the sample
      */
    RTI_INT32 publicationPriority;
    /*e
      Time when sample was sent
     */
    struct WriterHistory_IeeeTime sourceTimestamp;
    /*e
      Time when sample was received
     */
    struct WriterHistory_IeeeTime receptionTimestamp;
};

struct NDDS_WriterHistory_Statistics {
    /*e \brief sample count */
    RTI_INT32 sampleCount;
    RTI_INT32 sampleCountPeak;
};


#define NDDS_WRITER_HISTORY_STATISTICS_INITIALIZER { \
    0, 0 /* sampleCount, sampleCountPeak */ \
}


#define NDDS_WRITER_HISTORY_ROLE_NAME_MAX_SIZE MIG_RTPS_PATHNAME_LEN_MAX+1

struct NDDS_WriterHistory_DurableSubscriptionVirtualWriter {
    struct REDAInlineListNode _node;
    /* Virtual writer GUID */
    struct MIGRtpsGuid guid;
    /* List of sequence number intervals that have been ack by the durable
       subscription for the virtual writer */
    struct REDASequenceNumberIntervalList durAckIntervalList;
};

struct NDDS_WriterHistory_DurableSubscription {
    /* Durable subscription name */
    char name[NDDS_WRITER_HISTORY_ROLE_NAME_MAX_SIZE];
    /* This list is a list of virtual writer elements associated with the durable subscription */
    struct REDAInlineList durAckVirtualWriterList;
    RTI_INT64 changeEpoch;
    RTI_UINT32 quorum;
};


#define NDDS_WRITERHISTORY_VIRTUAL_SESSION_ID -1


#define NDDS_WRITERHISTORY_RETCODE_OK 0


#define NDDS_WRITERHISTORY_RETCODE_PRECONDITION_NOT_MET 1


#define NDDS_WRITERHISTORY_RETCODE_FAILURE_INTERNAL 2


#define NDDS_WRITERHISTORY_RETCODE_FULL 3


#define NDDS_WRITERHISTORY_RETCODE_RESOURCE_CONTENTION 4


#define NDDS_WRITERHISTORY_RETCODE_OUT_OF_RESOURCES 5


#define NDDS_WRITERHISTORY_RETCODE_NO_INSTANCE 6


#define NDDS_WRITERHISTORY_RETCODE_NO_SAMPLE 7


#define NDDS_WRITERHISTORY_RETCODE_OUT_OF_ORDER 8


#define NDDS_WRITERHISTORY_RETCODE_LIFESPAN_EXPIRED 9


#define NDDS_WRITERHISTORY_RETCODE_EMPTY_COHERENT_SET 10


#define NDDS_WRITERHISTORY_RETCODE_NOT_SUPPORTED 11


#define NDDS_WRITERHISTORY_RETCODE_BATCH_FULL 12


#define NDDS_WRITERHISTORY_RETCODE_INSTANCE_FULL 13


#define NDDS_WRITERHISTORY_RETCODE_SAMPLE_DISCARDED 14


#define NDDS_WRITERHISTORY_RETCODE_SEND_WINDOW_FULL 15


#define NDDS_WRITERHISTORY_RETCODE_RESERVED_RANGE 100

struct NDDS_WriterHistory_OriginalWriterInfo {
    /*e
      Writer GUID.
    */
    struct MIGRtpsGuid writerGuid;
    /*e
      Writer Sequence Number.
    */
    struct REDASequenceNumber sequenceNumber;
};

extern WRITERHISTORYDllExport RTIBool
NDDS_WriterHistory_OriginalWriterInfo_equals(
    struct NDDS_WriterHistory_OriginalWriterInfo * self,
    const struct NDDS_WriterHistory_OriginalWriterInfo * other);

struct NDDS_WriterHistory_FilterSampleInfo {
    /*e
      related original writerInfo
    */
    struct NDDS_WriterHistory_OriginalWriterInfo relatedOriginalWriterInfo;
    struct MIGRtpsGuid relatedSourceGuid;
    struct MIGRtpsGuid relatedReaderGuid;
    /*e
     Publication priority of the sample
     */
    RTI_INT32 publicationPriority;
};


#define NDDS_WRITER_HISTORY_FILTER_SAMPLE_INFO_DEFAULT {       \
    {MIG_RTPS_GUID_UNKNOWN,REDA_SEQUENCE_NUMBER_UNKNOWN} ,       \
    MIG_RTPS_GUID_UNKNOWN, \
    MIG_RTPS_GUID_UNKNOWN, \
    COMMEND_PUBLICATION_PRIORITY_UNDEFINED                     \
}

struct NDDS_WriterHistory_WriteParams {
    /*e @brief Related Reader GUID */
    struct MIGRtpsGuid relatedReaderGuid;
    /*e @brief Source GUID */    
    struct MIGRtpsGuid sourceGuid;
    /*e @brief Related Source GUID */        
    struct MIGRtpsGuid relatedSourceGuid;
    /*e @brief TopicQuery GUID */
    struct MIGRtpsGuid topicQueryGuid;
};


#define NDDS_WRITER_HISTORY_WRITE_PARAMS_DEFAULT {       \
    MIG_RTPS_GUID_UNKNOWN ,       \
    MIG_RTPS_GUID_UNKNOWN ,       \
    MIG_RTPS_GUID_UNKNOWN ,       \
    MIG_RTPS_GUID_UNKNOWN         \
}

struct NDDS_WriterHistory_Attribute {
    /*e @brief Attribute name. NULL terminated string. */
    char * name;
    /*e @brief Attribute value. NULL terminated string. */
    char * value;
};

struct NDDS_WriterHistory_AttributeSeq {
    /*e @brief The maximum number of elements in the attribute sequence */
    RTI_UINT32 maximum;

    /*e @brief The number of elements in the attribute sequence */
    RTI_UINT32 length;

    /*e @brief The name,value pairs in the attribute sequence */
    struct NDDS_WriterHistory_Attribute * attributes;
};

extern WRITERHISTORYDllExport const char *
NDDS_WriterHistory_AttributeSeq_get_attribute_value(struct NDDS_WriterHistory_AttributeSeq * self,
                                                    const char * name);

extern WRITERHISTORYDllExport struct NDDS_WriterHistory_Attribute *
NDDS_WriterHistory_AttributeSeq_get_attribute(struct NDDS_WriterHistory_AttributeSeq * self,
                                              const char * name);

extern WRITERHISTORYDllExport int
NDDS_WriterHistory_AttributeSeq_compare(const struct NDDS_WriterHistory_AttributeSeq * left,
                                        const struct NDDS_WriterHistory_AttributeSeq * right);

struct NDDS_WriterHistory_Allocator;

typedef void * NDDS_WriterHistory_AllocatorHandle;

typedef int (*NDDS_WriterHistory_Allocator_getBuffer_fn)(
    NDDS_WriterHistory_AllocatorHandle handle,
    struct REDABuffer *buffer,              /* Buffer to return ptr + length */
    RTIEncapsulationId encapsulationId,
    const void * user_data);                /* Can be NULL for batch */

typedef void (*NDDS_WriterHistory_Allocator_returnBuffer_fn)(
    NDDS_WriterHistory_AllocatorHandle handle,
    struct REDABuffer *buffer,             /* Buffer to release */
    RTIEncapsulationId encapsulationId);

typedef void (*NDDS_WriterHistory_Allocator_deleteAllocator_fn)(
    NDDS_WriterHistory_AllocatorHandle handle);

typedef NDDS_WriterHistory_AllocatorHandle (*NDDS_WriterHistory_Allocator_newAllocator_fn)(
    struct NDDS_WriterHistory_Listener * self,
    RTI_UINT32 max_buffer_size,
    int alignment,
    RTI_UINT32 initial_buffer_count);

struct NDDS_WriterHistory_Allocator {
    NDDS_WriterHistory_Allocator_newAllocator_fn     newAllocator;   /* Optional */
    NDDS_WriterHistory_Allocator_deleteAllocator_fn  deleteAllocator;/* Optional */
    NDDS_WriterHistory_Allocator_getBuffer_fn        getBuffer;      /* Mandatory */
    NDDS_WriterHistory_Allocator_returnBuffer_fn     returnBuffer;   /* Mandatory */
};

typedef RTI_INT32 (*NDDS_WriterHistory_Listener_InitializeSampleCallback)(
    struct NDDS_WriterHistory_Listener * self,
    struct NDDS_WriterHistory_Sample * sample_inout,
    const struct NDDS_WriterHistory_Instance * instance_in,
    RTIBool new_sample_in,
    MIGGeneratorEndian endian_in,
    const struct NDDS_WriterHistory_OriginalWriterInfo * original_writer_info_in,
    const struct NDDS_WriterHistory_OriginalWriterInfo * related_original_writer_info_in,
    RTI_INT32 sample_flags,
    const struct NDDS_WriterHistory_WriteParams * write_params,
    const void * user_data_in /* Deserialized data */);

typedef RTI_INT32 (*NDDS_WriterHistory_Listener_InitializeSampleInBatchCallback)(
    struct NDDS_WriterHistory_Listener * self,
    struct NDDS_WriterHistory_Sample * batch_inout,
    RTI_UINT32 max_serialized_data_size_in,
    RTI_UINT32 max_serialized_meta_data_size_in,
    NDDS_WriterHistory_SampleKind kind_in,
    const struct REDASequenceNumber * sn_in,
    const struct MIGRtpsKeyHash * instance_keyhash_in,
    const struct RTINtpTime * timestamp_in,
    const void * deserialized_user_data_in,
    const struct REDABuffer * serialized_user_data_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Listener_CloseBatchCallback)(
    struct NDDS_WriterHistory_Listener * self,
    struct NDDS_WriterHistory_Sample * batch_inout);

typedef RTI_INT32 (*NDDS_WriterHistory_Listener_FinalizeSampleCallback)(
    struct NDDS_WriterHistory_Listener * self,
    struct NDDS_WriterHistory_Sample * sample_out);

typedef RTI_INT32 (*NDDS_WriterHistory_Listener_FinalizeSampleInBatchCallback)(
    struct NDDS_WriterHistory_Listener * self,
    struct NDDS_WriterHistory_Sample * batch_inout,
    struct REDABuffer * sampleInfo_inout,
    int numberOfSamples_in,
    int sampleOffset_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Listener_InitializeInstanceCallback)(
    struct NDDS_WriterHistory_Listener * self,
    struct NDDS_WriterHistory_Instance * instance_inout,
    RTIBool new_instance_in,
    const void * key_data_in /* Deserialized user key */);

typedef RTI_INT32 (*NDDS_WriterHistory_Listener_FinalizeInstanceCallback)(
    struct NDDS_WriterHistory_Listener * self,
    struct NDDS_WriterHistory_Instance * instance_out);

typedef RTI_INT32 (*NDDS_WriterHistory_Listener_EvaluateSampleCallback)(
    struct NDDS_WriterHistory_Listener * self,
    const void * sample_data,
    const struct NDDS_WriterHistory_FilterSampleInfo * meta_data,
    RTI_INT32 sessionId,
    RTIBool *isPassed,
    RTIBool *isCacheable);

typedef RTI_INT32 (*NDDS_WriterHistory_Listener_OnRemoveSampleCallback)(
    struct NDDS_WriterHistory_Listener * self,
    struct REDABuffer *cookie);

typedef RTI_INT32 (*NDDS_WriterHistory_Listener_OnReplaceInstanceCallback)(
    struct NDDS_WriterHistory_Listener * self,
    struct MIGRtpsKeyHash * keyHash);

typedef RTI_INT32 (*NDDS_WriterHistory_Listener_OnAppAckCallback)(
    struct NDDS_WriterHistory_Listener * self,
    struct MIGRtpsGuid *writerGuid,
    struct REDASequenceNumber *vSN,
    struct REDABuffer *cookie,
    struct REDABuffer *response,
    RTIBool validResponse,
    struct MIGRtpsGuid *readerGuid,
    RTI_INT32 sessionId,
    struct REDASequenceNumber *sessionSN,
    void *storage);

typedef RTI_INT32 (*NDDS_WriterHistory_Listener_GetSampleSerializedSizeCallback)(
    struct NDDS_WriterHistory_Listener * self,
    RTI_UINT32 * size_inout,
    const void * sample_data);

struct NDDS_WriterHistory_Listener {
    /*e @brief Listener data

        A place for listener implementors to keep a pointer to data that may be
        needed by their listener.
    */
    void * listener_data;

    /*e @brief Contains a set of functions that are called for memory management
     * of the sample.
     */
    struct NDDS_WriterHistory_Allocator allocator;

    /*e @brief Initializes a new session sample added to the WH (not NULL).
    */
    NDDS_WriterHistory_Listener_InitializeSampleCallback initialize_sample;
    /*e @brief Finalizes a WH session sample.
    */
    NDDS_WriterHistory_Listener_FinalizeSampleCallback finalize_sample;
    /*e @brief Initializes a new instance added to the WH (not NULL).
    */
    NDDS_WriterHistory_Listener_InitializeInstanceCallback initialize_instance;
    /*e @brief Finalizes a WH instance.
    */
    NDDS_WriterHistory_Listener_FinalizeInstanceCallback finalize_instance;
    /*e @brief Closes a WH batch (not NULL if batching).
    */
    NDDS_WriterHistory_Listener_CloseBatchCallback close_batch;
    /*e @brief Finalizes a WH batch sample (not NULL if batching).
    */
    NDDS_WriterHistory_Listener_FinalizeSampleInBatchCallback finalize_sample_in_batch;
    /*e @brief Evaluates is a sample is to be sent and/or cached.
    */
    NDDS_WriterHistory_Listener_EvaluateSampleCallback evaluate_sample;
    /*e @brief Callback upon removal virtual sample
    */
    NDDS_WriterHistory_Listener_OnRemoveSampleCallback on_remove_sample;
    /*e @brief Callback upon instance being replaced
    */
    NDDS_WriterHistory_Listener_OnReplaceInstanceCallback on_replace_instance;
    /*e @brief Callback upon virtual sample being acknowledged
    */
    NDDS_WriterHistory_Listener_OnAppAckCallback on_app_ack;
    /*e @brief Callback to get the serialized size of a sample
    */
    NDDS_WriterHistory_Listener_GetSampleSerializedSizeCallback get_sample_serialized_size;    
};

extern WRITERHISTORYDllExport void
NDDS_WriterHistory_Listener_initialize(struct NDDS_WriterHistory_Listener * listener);

extern WRITERHISTORYDllExport RTIBool
NDDS_WriterHistory_Listener_is_valid(struct NDDS_WriterHistory_Listener * listener,RTIBool batching);


#define NDDS_WRITERHISTORY_INVALID_PLUGIN_CLASSID (-1)


#define NDDS_WRITERHISTORY_ANY_PLUGIN_CLASSID (0)


#define NDDS_WRITERHISTORY_MEMORY_PLUGIN_CLASSID (1)


#define NDDS_WRITERHISTORY_ODBC_PLUGIN_CLASSID (2)


#define NDDS_WRITERHISTORY_RESERVED_RANGE_PLUGIN_CLASSID  (1000)

typedef int NDDS_WriterHistory_PluginClassId;

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_CreateHistoryFcn) (
        struct NDDS_WriterHistory_Plugin * self,
        NDDS_WriterHistory_Handle * history_out,
        const struct NDDS_WriterHistory_Property * property_in,
        const struct NDDS_WriterHistory_Listener * history_listener_in,
        const struct MIGRtpsGuid * dw_guid_in,
        const struct MIGRtpsGuid * dw_virtual_guid_in,
        const struct NDDS_WriterHistory_AttributeSeq * dw_property_in,
        struct RTIClock * clock_in,
        void * reserved);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_DestroyHistoryFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    NDDS_WriterHistory_Handle history_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_AddSampleFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    RTI_UINT32 * sample_count_out,
    struct NDDS_WriterHistory_Sample * sample_out[],
    RTI_INT32 session_id_out[],
    struct REDASequenceNumber first_available_sn_out[],
    struct REDASequenceNumber first_available_virtual_sn_out[],
    NDDS_WriterHistory_Handle history_in,
    NDDS_WriterHistory_SampleKind kind_in,
    const struct MIGRtpsKeyHash * instance_keyhash_in,
    const struct RTINtpTime * timestamp_in,
    MIGGeneratorEndian endian_in,
    const void * user_data_in,
    struct REDABuffer *cookie_in,
    const struct COMMENDFilterStatus * filter_status_in,
    const struct MIGRtpsGuid * reader_guid_in,
    const struct NDDS_WriterHistory_OriginalWriterInfo * original_writer_info_in,
    const struct NDDS_WriterHistory_OriginalWriterInfo * related_original_writer_info_in,
    const struct RTINtpTime * now_in,
    RTI_INT32 publicationPriority,
    RTIBool create_instance,
    RTI_INT32 sample_flags,
    const struct NDDS_WriterHistory_WriteParams * write_params);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_AddHistoricalSampleFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    struct NDDS_WriterHistory_Sample ** sample_out,
    RTI_INT32 * sessionId_out,
    struct REDASequenceNumber * firstAvailableSn_out,
    struct REDASequenceNumber * firstAvailableVirtualSn_ou,
    NDDS_WriterHistory_Handle history_in,
    const struct NDDS_WriterHistory_Sample * sample_in,
    const struct RTINtpTime * timestamp_in,
    MIGGeneratorEndian endian_in,
    const struct MIGRtpsGuid * readerGuid_in,
    const struct RTINtpTime * now_in,
    RTI_INT32 sample_flags,
    const struct NDDS_WriterHistory_WriteParams * writeParams_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_AddBatchSampleGroupFcn)(
     struct NDDS_WriterHistory_Plugin * self,
     struct NDDS_WriterHistory_BatchSampleGroup * group_out, /* In/Out parameter */
     NDDS_WriterHistory_Handle history_in,
     const struct RTINtpTime * timestamp_in, /* Monotonic timestamp of the group */
     const struct RTINtpTime * now_in /* Current monotonic time */);

/*e \ingroup WriterHistoryPluginModule
  @brief Returns a session sample loan.

  A virtual sample will be considered as loaned if any of its session samples
  is loaned

  Indicates to the WH plugin that the caller is done accessing the input
  sample obtained by some earlier invocation of \ref NDDS_WriterHistory_Plugin_AddSampleFcn
  or \ref NDDS_WriterHistory_Plugin_FindSampleFcn.

  For the iterator function \ref NDDS_WriterHistory_Plugin_NextSampleFcn, the loan is
  automatically returned when we make the following call to
  \ref NDDS_WriterHistory_Plugin_NextSampleFcn, \ref NDDS_WriterHistory_Plugin_EndSampleIterationFcn
  or \ref NDDS_WriterHistory_Plugin_BeginSampleIterationFcn.

  @pre self, sampleReusable_out, history_in, and sample_in are not NULL.
  @pre The sample loanCount is bigger than 0.
  @pre The plugin class ID has the expected value. For example, for
  the builtin memory plugin that value would be \ref NDDS_WRITERHISTORY_MEMORY_PLUGIN_CLASSID.

  @param self \st_in WH plugin.
  @param sample_reusable_out \st_out This parameter will be initialized to
  RTI_TRUE if there are resources that could potentially
  be reused for new samples.
  @param history_in \st_in WH handle.
  @param sample_in \st_in Input sample.
  @param now_in \st_in The current time.

  @return
  On success, the function returns \ref NDDS_WRITERHISTORY_RETCODE_OK.<br>
  On failure, the function returns one of the following codes:<br>
     \ref NDDS_WRITERHISTORY_RETCODE_PRECONDITION_NOT_MET<br>
     \ref NDDS_WRITERHISTORY_RETCODE_FAILURE_INTERNAL
*/
typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_ReturnSampleLoanFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    RTIBool * sample_reusable_out,
    NDDS_WriterHistory_Handle history_in,
    struct NDDS_WriterHistory_Sample * sample_in,
    const struct RTINtpTime * now_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_FindSampleFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    struct NDDS_WriterHistory_Sample ** sample_out,
    struct REDASequenceNumber * first_relevant_sn_out,
    struct REDASequenceNumber * next_relevant_sn_out,
    struct REDASequenceNumber * first_relevant_virtual_sn_out,
    struct REDASequenceNumber * next_relevant_virtual_sn_out,
    NDDS_WriterHistory_Handle history_in,
    RTI_INT32 session_id_in,
    const struct REDASequenceNumber *request_sn_in,
    const struct MIGRtpsGuid *remoteReaderVirtualGuid,
    const struct RTINtpTime *now_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_GetFirstAvailableSnFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    struct REDASequenceNumber sn_out[],
    struct REDASequenceNumber virtual_sn_out[],
    NDDS_WriterHistory_Handle history_in,
    RTI_UINT32 session_count_in,
    const RTI_INT32 session_id_in[]);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_GetLastAvailableSnFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    struct REDASequenceNumber sn_out[],
    NDDS_WriterHistory_Handle history_in,
    RTI_UINT32 session_count_in,
    const RTI_INT32 session_id_in[]);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_CheckSampleKeepDurationFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    RTIBool *samplesReusable_out,
    struct REDASequenceNumber sn_out[],
    struct RTINtpTime timestamp_out[],
    NDDS_WriterHistory_Handle history_in,
    RTI_UINT32 session_count_in,
    const RTI_INT32 session_id_in[],
    const struct RTINtpTime *expiration_time_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_GetFirstNonReclaimableSnFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    struct REDASequenceNumber sn_out[],
    struct RTINtpTime timestamp_out[],
    NDDS_WriterHistory_Handle history_in,
    RTI_UINT32 session_count_in,
    const RTI_INT32 session_id_in[]);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_ChangeFirstNonReclaimableSnFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    RTIBool * samples_reusable_out,
    struct REDASequenceNumber * first_non_reclaimable_virtual_sn_out,
    NDDS_WriterHistory_Handle history_in,
    RTI_INT32 session_id_in,
    const struct MIGRtpsGuid *readerVirtualGuid,
    const RTIBool durSubOnly,
    const struct REDASequenceNumber * first_non_reclaimable_sn_in,
    const struct RTINtpTime *now_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_MakeSampleReclaimableFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    RTIBool * sample_reusable_out,
    NDDS_WriterHistory_Handle history_in,
    struct NDDS_WriterHistory_Sample * sample_in,
    RTI_INT32 session_id_in,
    const struct REDASequenceNumber * sn_in,
    const struct RTINtpTime *now_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_GetNonReclaimableSamplesCountFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    RTI_INT32 * count_out,
    NDDS_WriterHistory_Handle history_in,
    RTI_UINT32 session_count_in,
    const RTI_INT32 session_id_in[]);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_GetAppAckNonReclaimableSamplesCountFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    RTI_INT32 * count_out,
    NDDS_WriterHistory_Handle history_in,
    RTI_UINT32 session_count_in,
    const RTI_INT32 session_id_in[]);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_GetDurableSubscriptionNonReclaimableSamplesCountFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    const char * name,
    RTI_INT32 * count_out,
    NDDS_WriterHistory_Handle history_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_SetLifespanFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    NDDS_WriterHistory_Handle history_in,
    const struct RTINtpTime * lifespan_duration_in,
    const struct RTINtpTime *now_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_PruneLifespanExpiredSamplesFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    RTIBool * samples_reusable_out,
    NDDS_WriterHistory_Handle history_in,
    const struct RTINtpTime *now_in,
    RTIBool single_sample_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_BeginCoherentChangesFcn) (
    struct NDDS_WriterHistory_Plugin * self,
    NDDS_WriterHistory_Handle history_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_BeginSampleIterationFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    NDDS_WriterHistory_Handle history_in,
    RTI_INT32 session_id_in,
    const struct REDASequenceNumber * sn_in,
    RTIBool end_previous_iteration_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_NextSampleFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    struct NDDS_WriterHistory_Sample ** sample_out,
    NDDS_WriterHistory_Handle history_in,
    RTI_INT32 session_id_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_EndSampleIterationFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    NDDS_WriterHistory_Handle history_in,
    RTI_INT32 session_id_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_RegisterInstanceFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    NDDS_WriterHistory_Handle history_in,
    const struct MIGRtpsKeyHash * instance_keyHash_in,
    const void * instance_data_in,
    const struct RTINtpTime * timestamp_in,
    const struct RTINtpTime * now_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_UnregisterInstanceFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    NDDS_WriterHistory_Handle history_in,
    const struct MIGRtpsKeyHash * instance_keyHash_in,
    const struct RTINtpTime * timestamp_in,
    const struct RTINtpTime * now_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_FindInstanceFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    struct NDDS_WriterHistory_Instance ** instance_out,
    NDDS_WriterHistory_Handle history_in,
    const struct MIGRtpsKeyHash *instance_keyhash_in,
    RTIBool return_instance_loan_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_ReturnInstanceLoanFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    RTIBool * instance_reusable_out,
    NDDS_WriterHistory_Handle history_in,
    struct NDDS_WriterHistory_Instance * instance_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_SetDeadlineFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    NDDS_WriterHistory_Handle history_in,
    const struct RTINtpTime * deadline_period_in,
    const struct RTINtpTime *now_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_SetSampleKeepDurationFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    NDDS_WriterHistory_Handle history_in,
    const struct RTINtpTime * minKeepDuration_in,
    const struct RTINtpTime * maxKeepDuration_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_ScaleSampleKeepDurationFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    NDDS_WriterHistory_Handle history_in,
    RTI_INT32 sessionId_in,
    const struct RTINtpTime * keep_duration_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_CheckDeadlineFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    RTI_INT32 * deadline_missed_count_out,
    struct MIGRtpsKeyHash * last_instance_keyhash_out,
    struct RTINtpTime * min_next_deadline_out,
    NDDS_WriterHistory_Handle history_in,
    const struct RTINtpTime *now_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_BeginInstanceIterationFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    NDDS_WriterHistory_Handle history_in,
    const struct MIGRtpsKeyHash * instance_keyHash_in,
    RTIBool end_previous_iteration_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_NextInstanceFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    struct NDDS_WriterHistory_Instance ** instance_out,
    NDDS_WriterHistory_Handle history_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_EndInstanceIterationFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    NDDS_WriterHistory_Handle history_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_FlushBatchFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    RTI_UINT32 * sample_count_out,
    struct NDDS_WriterHistory_Sample * sample_out[],
    RTI_INT32 session_id_out[],
    struct REDASequenceNumber first_available_sn_out[],
    struct REDASequenceNumber first_available_virtual_sn_out[],
    NDDS_WriterHistory_Handle history_in,
    RTI_UINT32 session_count_in,
    const RTI_INT32 session_id_in[]);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_InitializeFcn)(
        struct NDDS_WriterHistory_Plugin * self,
        const struct NDDS_WriterHistory_AttributeSeq * dp_properties_in,
        void * reserved);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_DestroyFcn)(
        struct NDDS_WriterHistory_Plugin * self);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_GetStatisticsFcn)(
        struct NDDS_WriterHistory_Plugin * self,
        struct NDDS_WriterHistory_Statistics *stats_out,
        NDDS_WriterHistory_Handle history_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_SetStatisticsFcn)(
        struct NDDS_WriterHistory_Plugin * self,
        const struct NDDS_WriterHistory_Statistics *stats_in,
        NDDS_WriterHistory_Handle history_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_GetBatchInProgressFcn)(
        struct NDDS_WriterHistory_Plugin * self,
        struct NDDS_WriterHistory_Sample * batch_out[],
        NDDS_WriterHistory_Handle history_in,
        RTI_UINT32 session_count_in,
        RTI_INT32 session_id_in[],
        MIGGeneratorEndian endian_in,
        const struct MIGRtpsGuid * reader_guid_in,
        RTIBool in_coherent_set_in,
        const struct RTINtpTime * timestamp_in,
	const struct RTINtpTime * now_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_GetNextSnFcn)(
        struct NDDS_WriterHistory_Plugin * self,
        struct REDASequenceNumber sn_out[],
        NDDS_WriterHistory_Handle history_in,
        RTI_UINT32 session_count_in,
        RTI_INT32 session_id_in[]);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_GetLastAvailableVirtualSnFcn)(
        struct NDDS_WriterHistory_Plugin * self,
        struct REDASequenceNumber * sn_out,
        NDDS_WriterHistory_Handle history_in,
        const struct MIGRtpsGuid * guid_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_SetSampleKeepDurationMode)(
        struct NDDS_WriterHistory_Plugin * self,
        NDDS_WriterHistory_Handle history_in,
        RTI_UINT32 session_count_in,
        RTI_INT32 session_id_in[],
        RTIBool ackEnabledReaderPresent,
        RTIBool ackDisabledReaderPresent);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_GetSerializationBufferFcn)(
    struct NDDS_WriterHistory_Plugin *self,
    struct REDABuffer *buffer_out,
    NDDS_WriterHistory_Handle history_in,
    RTIEncapsulationId encapsulationId,
    const void *data);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_ReturnSerializationBufferFcn)(
    struct NDDS_WriterHistory_Plugin *self,
    struct REDABuffer *buffer_in,
    NDDS_WriterHistory_Handle history_in,
    RTIEncapsulationId encapsulationId);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_PurgeInstanceFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    NDDS_WriterHistory_Handle history_in,
    const struct MIGRtpsKeyHash *instanceKeyHash_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_AssertRemoteReaderFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    RTIBool *sampleReclaimable_out,
    NDDS_WriterHistory_Handle history_in,
    const struct MIGRtpsGuid *remoteReaderGuid,
    const struct MIGRtpsGuid *remoteReaderVirtualGuid,
    const char * roleName,
    NDDS_WriterHistory_AckMode ackMode,
    RTI_INT32 sessionId,
    RTIBool readerIsActive);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_RemoveRemoteReaderFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    RTIBool *spaceAvailable_out,
    NDDS_WriterHistory_Handle history_in,
    const struct MIGRtpsGuid *remoteReaderGuid,
    const struct MIGRtpsGuid *remoteReaderVirtualGuid,
    NDDS_WriterHistory_AckMode ackMode,
    RTI_INT32 sessionId);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_AssertAppAckFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    RTIBool *sampleReclaimable_out,
    NDDS_WriterHistory_Handle history_in,
    struct MIGRtpsAppAckPerVirtualWriter *vwAppAck,
    const struct MIGRtpsGuid *remoteReaderGuid,
    const struct MIGRtpsGuid *remoteReaderVirtualGuid,
    RTI_INT32 sessionId,
    const struct RTINtpTime *now,
    void *listenerStorage);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_SetDurableSubscriptionsFcn)(
    struct NDDS_WriterHistory_Plugin *self,
    RTIBool *sampleReusable_out,
    NDDS_WriterHistory_Handle history_in,
    struct NDDS_WriterHistory_EndpointGroup *buffer,
    int length);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_GetDurableSubscriptionInfoFcn)(
    struct NDDS_WriterHistory_Plugin *self,
    struct NDDS_WriterHistory_DurableSubscription ** durSub_out,
    NDDS_WriterHistory_Handle history_in,
    const char * durSubName_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_SetDurableSubscriptionInfoFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    NDDS_WriterHistory_Handle history_in,
    const struct NDDS_WriterHistory_DurableSubscription * durSub_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_getWriterInfoFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    struct MIGRtpsWriterInfo **writerInfo,
    NDDS_WriterHistory_Handle history_in, RTI_INT32 sessionId);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_setAutopurgeInstanceOnUnregisterDelay)(
    struct NDDS_WriterHistory_Plugin * self,
    NDDS_WriterHistory_Handle history_in,
    const struct RTINtpTime * autopurgeInstanceOnUnDelay_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_IsSampleAppAckFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    RTIBool * is_app_ack,
    NDDS_WriterHistory_Handle history_in,
    const struct NDDS_WriterHistory_OriginalWriterInfo * identity);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_GetSessionSampleCountFcn)(
    struct NDDS_WriterHistory_Plugin * self,
    RTIBool *sampleCount_out,
    NDDS_WriterHistory_Handle history_in,
    RTI_INT32 sessionId_in);

typedef RTI_INT32 (*NDDS_WriterHistory_Plugin_GetCryptoTokensFcn)(
    struct NDDS_WriterHistory_Plugin *self, struct REDABuffer **buffer,
    NDDS_WriterHistory_Handle history_in);

struct NDDS_WriterHistory_Plugin {
    /*e @brief Plugin class
    */
    NDDS_WriterHistory_PluginClassId classId;
    /*e @brief Creates a new WH.
    */
    NDDS_WriterHistory_Plugin_CreateHistoryFcn create_history;
    /*e @brief Destroys a WH.
    */
    NDDS_WriterHistory_Plugin_DestroyHistoryFcn destroy_history;
    /*e @brief Adds a sample to the input WH.
    */
    NDDS_WriterHistory_Plugin_AddSampleFcn add_sample;
    /*e @brief Adds a group of samples to the input WH.
    */
    NDDS_WriterHistory_Plugin_AddBatchSampleGroupFcn add_batch_sample_group;

    /*e @brief Adds an existing virtual sample to the WH historical session
    */
    NDDS_WriterHistory_Plugin_AddHistoricalSampleFcn add_historical_sample;

    /*e @brief Returns a sample loan.
    */
    NDDS_WriterHistory_Plugin_ReturnSampleLoanFcn return_sample_loan;
    /*e @brief Finds a sample in the input WH.
    */
    NDDS_WriterHistory_Plugin_FindSampleFcn find_sample;
    /*e @brief Returns the first available sequence number in the input WH.
    */
    NDDS_WriterHistory_Plugin_GetFirstAvailableSnFcn get_first_available_sn;
    /*e @brief Returns the last available sequence number in the input WH.
    */
    NDDS_WriterHistory_Plugin_GetLastAvailableSnFcn get_last_available_sn;
    /*e @brief Returns the first non reclaimable sequence number in the input WH.
    */
    NDDS_WriterHistory_Plugin_GetFirstNonReclaimableSnFcn get_first_non_reclaimable_sn;
    /*e @brief Returns the first non expired sequence number in the input WH.
    */
    NDDS_WriterHistory_Plugin_CheckSampleKeepDurationFcn check_sample_keep_duration;
    /*e @brief Notifies the input WH that the first non reclaimable sequence number
        has changed.
    */
    NDDS_WriterHistory_Plugin_ChangeFirstNonReclaimableSnFcn change_first_non_reclaimable_sn;
    /*e @brief Notifies the input WH that a sample must be made reclaimable.
    */
    NDDS_WriterHistory_Plugin_MakeSampleReclaimableFcn make_sample_reclaimable;
    /*e @brief Gets a count of the non-reclaimable samples.
    */
    NDDS_WriterHistory_Plugin_GetNonReclaimableSamplesCountFcn get_non_reclaimable_samples_count;

    /*e @brief Gets a count of non application-level acknowledged samples.
    */
    NDDS_WriterHistory_Plugin_GetAppAckNonReclaimableSamplesCountFcn get_app_ack_non_reclaimable_samples_count;
    /*e @brief Set the WH lifespan duration.
    */
    NDDS_WriterHistory_Plugin_SetLifespanFcn set_lifespan;
    /*e @brief Prunes WH lifespan expired samples.
    */
    NDDS_WriterHistory_Plugin_PruneLifespanExpiredSamplesFcn prune_lifespan_expired_samples;
    /*e @brief Begins a coherent change in the WH.
    */
    NDDS_WriterHistory_Plugin_BeginCoherentChangesFcn begin_coherent_changes;
    /*e @brief Begins an iterator access to the samples held by the input WH.
    */
    NDDS_WriterHistory_Plugin_BeginSampleIterationFcn begin_sample_iteration;
    /*e @brief Gets the next sample held by the input WH in iteration.
    */
    NDDS_WriterHistory_Plugin_NextSampleFcn next_sample;
    /*e @brief Ends iterator access to the samples held by the WH.
    */
    NDDS_WriterHistory_Plugin_EndSampleIterationFcn end_sample_iteration;
    /*e @brief Registers a WH instance.
    */
    NDDS_WriterHistory_Plugin_RegisterInstanceFcn register_instance;
    /*e @brief Unregisters a WH instance.
    */
    NDDS_WriterHistory_Plugin_UnregisterInstanceFcn unregister_instance;
    /*e @brief Finds an instance in the input WH.
    */
    NDDS_WriterHistory_Plugin_FindInstanceFcn find_instance;
    /*e @brief Returns an instance loan.
    */
    NDDS_WriterHistory_Plugin_ReturnInstanceLoanFcn return_instance_loan;
    /*e @brief Set the WH deadline period.
    */
    NDDS_WriterHistory_Plugin_SetDeadlineFcn set_deadline;
    /*e @brief Set the WH sample keep duration.
    */
    NDDS_WriterHistory_Plugin_SetSampleKeepDurationFcn set_sample_keep_duration;
    /*e @brief Scale the WH sample keep duration.
    */
    NDDS_WriterHistory_Plugin_ScaleSampleKeepDurationFcn scale_sample_keep_duration;
    /*e @brief Checks the WH instances deadline.
    */
    NDDS_WriterHistory_Plugin_CheckDeadlineFcn check_deadline;
    /*e @brief Begins an iterator access to the instances held by the input WH.
    */
    NDDS_WriterHistory_Plugin_BeginInstanceIterationFcn begin_instance_iteration;
    /*e @brief Gets the next instance held by the input WH in iteration.
    */
    NDDS_WriterHistory_Plugin_NextInstanceFcn next_instance;
    /*e @brief Ends iterator access to the instances held by the input WH.
    */
    NDDS_WriterHistory_Plugin_EndInstanceIterationFcn end_instance_iteration;
    /*e @brief Flush the current batches
    */
    NDDS_WriterHistory_Plugin_FlushBatchFcn flush_batch;
    /*e @brief Initializes the input WH plugin.
    */
    NDDS_WriterHistory_Plugin_InitializeFcn initialize;
    /*e @brief Destroys the input WH plugin.
    */
    NDDS_WriterHistory_Plugin_DestroyFcn destroy;
    /*e @brief Get statistics of the WH.
    */
    NDDS_WriterHistory_Plugin_GetStatisticsFcn get_statistics;
    /*e @brief Set statistics of the WH.
    */
    NDDS_WriterHistory_Plugin_SetStatisticsFcn set_statistics;
    /*e @brief Gets the batches in progress of the input WH.
    */
    NDDS_WriterHistory_Plugin_GetBatchInProgressFcn get_batch_in_progress;
    /*e @brief Gets the batches in progress of the input WH.
    */
    NDDS_WriterHistory_Plugin_GetNextSnFcn get_next_sn;
    /*e @brief Gets the next virtual SN for a virtual GUID
    */
    NDDS_WriterHistory_Plugin_GetLastAvailableVirtualSnFcn get_last_available_virtual_sn;
    /*e @brief Sets the auto ACK-delay mode of the WH.
    */
    NDDS_WriterHistory_Plugin_SetSampleKeepDurationMode set_sample_keep_duration_mode;
    /*e
    */
    NDDS_WriterHistory_Plugin_GetSerializationBufferFcn get_serialization_buffer;
    /*e
    */
    NDDS_WriterHistory_Plugin_ReturnSerializationBufferFcn return_serialization_buffer;
    /*e
    */
    NDDS_WriterHistory_Plugin_PurgeInstanceFcn purge_instance;
    /*e
    */
    NDDS_WriterHistory_Plugin_AssertRemoteReaderFcn assert_remote_reader;
    /*e
    */
    NDDS_WriterHistory_Plugin_RemoveRemoteReaderFcn remove_remote_reader;
    /*e
    */
    NDDS_WriterHistory_Plugin_AssertAppAckFcn assert_app_ack;
    /*e
    */
    NDDS_WriterHistory_Plugin_SetDurableSubscriptionsFcn set_durable_subscriptions;
    /*e
    */
    NDDS_WriterHistory_Plugin_GetDurableSubscriptionInfoFcn get_durable_subscription_info;
    /*e
    */
    NDDS_WriterHistory_Plugin_SetDurableSubscriptionInfoFcn set_durable_subscription_info;
    /*e
    */
    NDDS_WriterHistory_Plugin_getWriterInfoFcn get_writer_info;
    /*e
    */
    NDDS_WriterHistory_Plugin_setAutopurgeInstanceOnUnregisterDelay set_autopurge_instance_on_unregister_delay;
    /*e
    */
    NDDS_WriterHistory_Plugin_setAutopurgeInstanceOnUnregisterDelay set_autopurge_instance_on_dispose_delay;
    /*e
     */
    NDDS_WriterHistory_Plugin_IsSampleAppAckFcn is_sample_app_ack;

    /*e
     * Gets the number of session samples currently in a specific session.
     *
     * While get_statistics returns the number of virtual samples (entries), a
     * global count, this function returns the number of "physical" samples
     * (session samples) for a specific session ID.
     */
    NDDS_WriterHistory_Plugin_GetSessionSampleCountFcn get_session_sample_count;

    /*e
     */
    NDDS_WriterHistory_Plugin_GetCryptoTokensFcn get_crypto_tokens;

    /*e
     */
    NDDS_WriterHistory_Plugin_DestroyHistoryFcn return_crypto_tokens;
};



#ifdef __cplusplus
    }	/* extern "C" */
#endif

#include "writer_history/writer_history_interface_impl.h"

#endif /* writer_history_interface_h */
