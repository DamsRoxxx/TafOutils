/* (c) Copyright 2003-2015, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)commend_srReaderService.h    generated by: makeheader    Fri Feb 16 13:51:38 2018
 *
 *		built from:	srReaderService.ifc
 */

#ifndef commend_srReaderService_h
#define commend_srReaderService_h


  #ifndef reda_worker_h
    #include "reda/reda_worker.h"
  #endif
  #ifndef reda_weakReference_h
    #include "reda/reda_weakReference.h"
  #endif
  #ifndef reda_database_h
    #include "reda/reda_database.h"
  #endif
  #ifndef netio_common_h
    #include "netio/netio_common.h"
  #endif
  #ifndef mig_rtps_h
    #include "mig/mig_rtps.h"
  #endif
  #ifndef commend_dll_h
    #include "commend/commend_dll.h"
  #endif
  #ifndef commend_readerService_h
    #include "commend/commend_readerService.h"
  #endif

#ifdef __cplusplus
    extern "C" {
#endif

struct RTIClock;

struct REDADatabase;

struct COMMENDFacade;

struct COMMENDSrReaderService;


/* This is a testing property used to set the initial EPOCH for NACK messages.
 * See CORE-7133 */
#define COMMEND_READER_NACK_EPOCH "dds.data_reader.initial_ack_epoch"

struct COMMENDSrReaderServiceReaderProperty {
    /*e Inherits the base reader properties.  */
    struct COMMENDReaderServiceReaderProperty parent;
    /*e The rate to send periodic ACK messages. 
      If zero, no periodic ACKS are sent. */
    struct RTINtpTime ackRate;
    /*e Max number of ACK retries before a remote writer is considered dead. */
    int ackRetriesMax;
    /* Suppress HBs that would trigger redundant ACKs; 
       necessary to avoid network storm in reboot case;
       Should be at least the time it takes for a writer to respond to a NACK,
       which would of course depend on writer's nack_response_delay.
     */
    struct RTINtpTime heartbeatSuppressionDuration;

    int requestDepth;

    RTIBool disableAcks;

    /*e This member must be set to RTI_TRUE to disable the preemptive NACK */
    RTIBool disablePreemptiveNack;
    
    /*e Size of reliability receive window */
    int receiveWindowSize;

    /*e Estimate of packet round trip time */
    struct RTINtpTime rtt;

    /*e  Max number of remote writers per reader */
    struct REDAFastBufferPoolGrowthProperty remoteWriterCount;

    /* alex TODO: rename type? */
    COMMENDAppAckMode appAckMode;

    /*e The rate to send application-level acks. Only applies if
        appAckMode != PROTOCOL */
    struct RTINtpTime appAckFlushRate;

    /*e
     * The following field is used only for testing purposes to set the initial
     * epoch for NACK messages.
     */
    REDAEpoch initialAckEpoch;

    /*e Security behavior of the reader */
    struct MIGGeneratorSecurityProperty security;
};


  #define COMMEND_SR_READER_SERVICE_READER_PROPERTY_DEFAULT { \
  COMMEND_READER_SERVICE_READER_PROPERTY_DEFAULT,             \
  {5, 0}, /* ackRate */ \
  10, /* ackRetriesMax */ \
  {0, 0x08000000}, /* heartbeatSuppressionDuration, default: 31 ms */ \
  0, /* requestDepth */ \
  RTI_FALSE, /* disableAcks */ \
  RTI_FALSE, /* disablePreemptiveNack */\
  256, /* receiveWindowSize */ \
  RTI_NTP_TIME_ZERO, /* rtt */ \
  REDA_FAST_BUFFER_POOL_GROWTH_PROPERTY_DEFAULT, /* maxRemoteWriters */ \
  COMMEND_PROTOCOL_ACK_MODE, /* appAckMode */\
  {5, 0}, /* appAckFlushRate */ \
  0, /* initialAckEpoch */ \
  MIG_GENERATOR_SECURITY_PROPERTY_DEFAULT /* security */ \
}

struct COMMENDSrReaderServiceRemoteWriterProperty {
    /*e immutable. Queue size of this remote writer.
        -1 means infinite (because the default resource limit QoS is unlimited,
        or -1).
	This is used to size the Bitmap of the samples to collect for the
	instance of the remote writer, so anything larger than
	MIG_RTPS_BITMAP_SIZE_MAX will be cutoff.
    */
    int queueSize;

    /*e immutable. Max size of ACK's bitmap. This limits the number of ISSUEs or
      VARs that can be requested at once from the remote writer.*/
    int dataToNackAtOnceMax;
    
    /*e immutable. Description of the destination where to send the ACK. */
    struct RTINetioLocator ackDestination[
	COMMEND_COMMON_APP_IPADDRESS_COUNT_MAX];
    /*e immutable. Size of destination array to send the ACK. */
    int ackDestinationCount;
    /*e mutable. Array of locators associated with locator-filter session */
    struct RTINetioLocator sessionLocatorList[
        COMMEND_COMMON_APP_IPADDRESS_COUNT_MAX];
    /*e mutable. Size of locator array for associated session */
    int sessionLocatorCount;
    /*e immutable. The last available sn of the remote writer. UNKNOWN if 
      unknown */
    struct REDASequenceNumber lastSn;
    /*e immutable. The last comitted sn for the remote writer */
    struct REDASequenceNumber lastComittedSn;
    /*e immutable. Whether remote writer service is persistent. */
    RTIBool isPersistentService;
    /*e immutable.  Whether remote writer allows and handles ACKs */
    RTIBool disableAcks;    
    /*e Flag determining fragmentBitmap's starting SN */
    RTIBool startFragmentBitmapFromZero;
    /*e Indicates if the shared memory transport associated to this remote
     *  reader is incompatible with the one of the local participant. */
    RTIBool incompatibleShmemTransport;
    /*e
     * SEC-82: remote writer and remote participant interceptor handle nodes
     * for matched list and directed list.
     */
    struct MIGInterceptorHandlesGroup interceptorHandles;
};


  #define COMMEND_SR_READER_SERVICE_REMOTE_WRITER_PROPERTY_DEFAULT { \
    32, /* queueSize */                                              \
    32, /* maxDataToNackAtOnce */                                    \
    RTI_NETIO_RTPS_LOCATOR_LIST_DEFAULT, /* ackDestination */        \
    0, /* ackDestinationCount */                                     \
    RTI_NETIO_RTPS_LOCATOR_LIST_DEFAULT, /* sessionLocator */        \
    0, /* sessionLocatorCount */                                     \
    REDA_SEQUENCE_NUMBER_UNKNOWN, /* lastSn */                        \
    REDA_SEQUENCE_NUMBER_UNKNOWN, /* lastComittedSn */                 \
    RTI_FALSE, /* isPersistentService */ \
    RTI_FALSE, /* disableAcks */          \
    RTI_FALSE, /* startFragmentBitmapFromZero */ \
    RTI_FALSE, /* incompatibleShmemTransport */ \
    MIGInterceptorHandlesGroup_INITIALIZER /* interceptorHandles */ \
}

extern COMMENDDllExport struct COMMENDSrReaderService *
COMMENDSrReaderService_new(
    struct REDADatabase *db, struct COMMENDFacade *facade,
    const struct COMMENDReaderServiceProperty *property,
    struct REDAExclusiveArea *ea, struct REDAWorker *worker);


#ifdef __cplusplus
    }	/* extern "C" */
#endif

  #include "commend/commend_srReaderService_impl.h"

#endif /* commend_srReaderService_h */
