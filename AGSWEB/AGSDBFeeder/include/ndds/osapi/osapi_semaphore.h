/* (c) Copyright 2003-2015, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)osapi_semaphore.h    generated by: makeheader    Fri Feb 16 13:51:09 2018
 *
 *		built from:	semaphore.ifc
 */

#ifndef osapi_semaphore_h
#define osapi_semaphore_h


  #ifndef log_common_h
    #include "log/log_common.h"
  #endif
  #ifndef osapi_log_h
    #include "osapi/osapi_log.h"
  #endif

  #ifndef osapi_type_h
    #include "osapi/osapi_type.h"
  #endif

#if defined(RTI_WIN32)
/*
 * FARO-264: winsock2.h needs to be included before windows.h.
 * Since windows.h in turn includes winsock.h, if winsock2.h is included 
 * later, then we will end up with both winsock.h and winsock2.h leading
 * to redefinition errors. 
*/
#if !defined(_WINSOCK2API_) && !defined(_WINSOCKAPI_)
  #include <winsock2.h>
#endif
  #include <windows.h>
#elif defined(RTI_POSIX_THREADS)
  #include <pthread.h>
#endif

#ifdef __cplusplus
    extern "C" {
#endif

struct RTIOsapiSemaphore;/* forward declare */

struct RTINtpTime;/* we count represent time with RTINtpTime */

typedef enum {
    /*e \brief Binary sempahore.
     */
    RTI_OSAPI_SEMAPHORE_KIND_BINARY =
    RTI_LOG_formSubmoduleSpecificNumber(MODULE_OSAPI,
					RTI_OSAPI_SUBMODULE_MASK_SEMAPHORE, 0),
    /*e \brief Counting sempahore.
     */
    RTI_OSAPI_SEMAPHORE_KIND_COUNTING =
    RTI_LOG_formSubmoduleSpecificNumber(MODULE_OSAPI,
					RTI_OSAPI_SUBMODULE_MASK_SEMAPHORE, 1),
    /*e \brief Mutex semaphore.
     */
    RTI_OSAPI_SEMAPHORE_KIND_MUTEX =
    RTI_LOG_formSubmoduleSpecificNumber(MODULE_OSAPI,
					RTI_OSAPI_SUBMODULE_MASK_SEMAPHORE, 2),

    /*e Broadcast semantics is the same as pthread_cond_broadcast
      http://www.cs.wustl.edu/~schmidt/win32-cv-1.html is an excellent related
      material.
     */
    RTI_OSAPI_SEMAPHORE_KIND_BROADCAST =
    RTI_LOG_formSubmoduleSpecificNumber(MODULE_OSAPI,
					RTI_OSAPI_SUBMODULE_MASK_SEMAPHORE, 3)
} RTIOsapiSemaphoreKind;

typedef enum {
    /*e The order threads are awaken is first in first out. */
    RTI_SEMAPHORE_THREAD_QUEUE_OPTION_FIFO = 0x0, 
    /*e The order threads are awaken is determined by their priority. */
    RTI_SEMAPHORE_THREAD_QUEUE_OPTION_PRIORITY = 0x1 
} RTIOsapiSemaphoreThreadQueueOption;

struct RTIOsapiSemaphoreProperty {
    /*e \brief Thread wakeup option.

      Irrelevant on some OSes.
     */
    RTIOsapiSemaphoreThreadQueueOption queueOption;

    /*e
      @param initialCountIn
      <UL>
      <LI>for counting semaphore, the initial count.  0 means the
          semaphore starts out being empty, so that the first take() will block
      <LI>for binary semaphore, 0 means initially empty, and non-zero means
          initially full.
      <LI>for mutex semaphore, count is irrelevant.
    </UL>
    */
    int initialCount;
};


  /*e \ingroup RTIOsapiSemaphoreClass
   * @brief Default property values.
   */
  #define RTI_OSAPI_SEMAPHORE_PROPERTY_DEFAULT { \
    RTI_SEMAPHORE_THREAD_QUEUE_OPTION_FIFO, \
    0 \
  }

extern RTIOsapiDllExport
struct RTIOsapiSemaphore*
RTIOsapiSemaphore_new(RTIOsapiSemaphoreKind kindIn,
		      const struct RTIOsapiSemaphoreProperty* pIn);

extern RTIOsapiDllExport void
RTIOsapiSemaphore_delete(struct RTIOsapiSemaphore* me);

typedef enum {
    /*e \brief The operation succeeded.
     */
    RTI_OSAPI_SEMAPHORE_STATUS_OK =
    RTI_LOG_formSubmoduleSpecificNumber(MODULE_OSAPI,
					RTI_OSAPI_SUBMODULE_MASK_SEMAPHORE,
					0xF0),
    /*e \brief The operation timed out.
     */
    RTI_OSAPI_SEMAPHORE_STATUS_TIMEOUT =
    RTI_LOG_formSubmoduleSpecificNumber(MODULE_OSAPI,
					RTI_OSAPI_SUBMODULE_MASK_SEMAPHORE,
					0xF1),
    /*e \brief An error occurred.
     */
    RTI_OSAPI_SEMAPHORE_STATUS_ERROR =
    RTI_LOG_formSubmoduleSpecificNumber(MODULE_OSAPI,
					RTI_OSAPI_SUBMODULE_MASK_SEMAPHORE,
					0xFF)
} RTIOsapiSemaphoreStatus;

extern RTIOsapiDllExport RTIOsapiSemaphoreStatus
RTIOsapiSemaphore_take(struct RTIOsapiSemaphore* me,
		       const struct RTINtpTime* blockDurationIn);

extern RTIOsapiDllExport RTIOsapiSemaphoreStatus
RTIOsapiSemaphore_give(struct RTIOsapiSemaphore* me);


#if defined(RTI_WIN32)
  typedef struct RTIOsapiGlobalLock {
      volatile int cs_init;
      volatile int cs_ready;
      CRITICAL_SECTION lock;
  } RTIOsapiGlobalLock;
  #define RTIOsapiGlobalLock_INITIALIZER {0,0,0}
#elif defined(RTI_POSIX_THREADS)
  typedef pthread_mutex_t RTIOsapiGlobalLock;
  #define  RTIOsapiGlobalLock_INITIALIZER PTHREAD_MUTEX_INITIALIZER;
#else
  /* Global lock not supported, includes VxWorks platforms */
  typedef int RTIOsapiGlobalLock;
  #define RTIOsapiGlobalLock_INITIALIZER 0;
#endif

extern RTIOsapiDllExport RTI_INT32 RTIOsapi_global_lock();

extern RTIOsapiDllExport RTI_INT32 RTIOsapi_global_unlock();

extern RTIOsapiDllExport
RTI_INT32 RTIOsapi_globalLock(RTIOsapiGlobalLock *lock);

extern RTIOsapiDllExport
RTI_INT32 RTIOsapi_globalUnlock(RTIOsapiGlobalLock *lock);


#ifdef __cplusplus
    }	/* extern "C" */
#endif

#endif /* osapi_semaphore_h */
