/* (c) Copyright 2003-2015, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)reda_string.h    generated by: makeheader    Fri Feb 16 13:51:18 2018
 *
 *		built from:	string.ifc
 */

#ifndef reda_string_h
#define reda_string_h


  #ifndef osapi_type_h
    #include "osapi/osapi_type.h"
  #endif
  #ifndef reda_dll_h
    #include "reda/reda_dll.h"
  #endif

#ifdef __cplusplus
    extern "C" {
#endif

extern REDADllExport const char*
REDAString_getToken(int *tokenLength, const char *s, char c);

extern REDADllExport const char*
REDAString_getLastToken(const char *str, char separator);

extern REDADllExport int
REDAString_getTokenCount(const char *str, char separator);

extern REDADllExport RTIBool REDAString_hasCommonElement(
    const char* delimitorSeparatedString1,
    const char* delimitorSeparatedString2,
    char delimitor);

extern REDADllExport RTIBool REDAString_hasMatchingElement(
    const char* delimitorSeparatedString1,
    const char* delimitorSeparatedString2,
    char delimitor);

extern REDADllExport RTIBool REDAString_hasMatchingElementX(
    const char* delimitorSeparatedString1,
    const char* delimitorSeparatedString2,
    char delimitor,
    void* param);

extern REDADllExport RTIBool REDAString_hasIntersectingPattern(
    const char* delimitorSeparatedString1,
    const char* delimitorSeparatedString2,
    char delimitor,
    void* param);

extern REDADllExport RTIBool REDAString_isPattern(const char *str);

extern REDADllExport RTIBool
REDAString_hasPatternsOnly(const char* s, char c);

extern REDADllExport char* REDAString_duplicate(const char* s);

extern REDADllExport char* REDAString_replace(
        char** dest,
        const char *source);

extern void REDAString_trimEnd(char * s);

extern REDADllExport void REDAString_printBytes(const char *buffer,
						int bufferSize);

extern REDADllVariable const int REDA_STRING_INDENT_AMOUNT;

extern REDADllExport void REDAString_printIndent(int indent);

extern REDADllExport void REDAString_printSpace(int count);

extern REDADllExport int REDAString_iCompare(const char* s1, const char* s2);

extern REDADllExport int REDAString_inCompare(const char* s1, const char* s2, int n);

extern REDADllExport char * REDAString_iFindSubString(const char* s1, const char* s2);

extern REDADllExport
RTIBool REDAString_strToBoolean(
    const char * str, RTIBool *boolOut);

extern REDADllExport RTIBool REDAString_validateName(int* index,
                                                     int* diff,
                                                     char* inString,
                                                     char** referenceStrings,
                                                     RTIBool caseSensitive);



/*e \ingroup REDAStringClass
 * Function fnmatch() as specified in POSIX 1003.2-1992, section B.6.
 * Compares a filename or pathname to a pattern.
 */

/*e \ingroup REDAStringClass
 * fnmatch() return values. */
#define REDA_STRING_FNM_NOMATCH     1       /* Match failed. */

/* fnmatch() flags. */


/*e \ingroup REDAStringClass
  Normally, every occurrence of a backslash ('\') followed by a character
  in pattern is replaced by that character.

  If REDA_STRING_FNM_NOESCAPE flag is set, a backslash character in pattern 
  parameter is treated as an ordinary character.
 */
#define REDA_STRING_FNM_NOESCAPE    0x01    /* Disable backslash escaping. */

/*e \ingroup REDAStringClass
  If the REDA_STRING_FNM_PATHNAME flag is not set, the / in string parameter is treated as
  an ordinary character.

  If the REDA_STRING_FNM_PATHNAME flag is set in the flags parameter, a / (slash) in the
  string parameter is explicitly matched by a / in the pattern parameter.
  It is not matched by either the * (asterisk) or ? (question-mark) special
  characters, nor by a bracket expression.
  Slash in the string parameter only matches slash in the pattern parameter.
 */
#define REDA_STRING_FNM_PATHNAME    0x02    /* Slash must be matched by slash. */

/*e \ingroup REDAStringClass
  If REDA_STRING_FNM_PERIOD is not set, no special restrictions are placed on matching a
  period in string parameter.

  If REDA_STRING_FNM_PERIOD is set in the flags parameter, then a leading period in the
  string parameter only matches a period in the pattern parameter;
  it is not matched by either the asterisk or question-mark special characters,
  not by a bracket expression. A period is determined to be leading according
  to the setting of the REDA_STRING_FNM_PATHNAME flag, according to the following rules:

  If the REDA_STRING_FNM_PATHNAME flag is set, a period is leading only if it is the
  first character in the string parameter or if it immediately follows a
  slash.

  If the REDA_STRING_FNM_PATHNAME flag is not set,  a period is leading only if it
  is the first character of the string parameter.
*/
#define REDA_STRING_FNM_PERIOD      0x04    /* Period must be matched by period. */

/*e \ingroup REDAStringClass
  If this flag is set, the pattern is considered to be matched if it
  matches an initial segment of string which is followed by a slash.
 */
#define REDA_STRING_FNM_LEADING_DIR 0x08    /* Ignore /<tail> after Imatch. */

/*e \ingroup REDAStringClass
  The pattern is matched in a case-insensitive fashion.
 */
#define REDA_STRING_FNM_CASEFOLD    0x10    /* Case insensitive search. */

/*e \ingroup REDAStringClass
  Applies if REDA_STRING_FNM_PATHNAME and NOT REDA_STRING_FNM_PERIOD.
  Redefines the path delimiter as a "." instead of a "/"
 */
#define REDA_STRING_FNM_DOTTED_PATH 0x20    /* Changes Slash to a Period */


extern REDADllExport
int REDAString_fnmatch(const char *matchPattern, const char *matchString,
		       int matchFlags);


typedef enum {
    SQL_OP_EQ,
    SQL_OP_NE,
    SQL_OP_GT,
    SQL_OP_LT,
    SQL_OP_GE,
    SQL_OP_LE,
    SQL_OP_BT,
    SQL_OP_MATCH
} SQLRelationshipKind;


typedef struct SQL_filter_term * SQL_filter_term_ptr;


typedef struct SQL_filter_term {
    SQL_filter_term_ptr next_AND;   /* next term in AND expression */
    SQL_filter_term_ptr next_OR;    /* next term in OR expression */
    SQL_filter_term_ptr tail;       /* last term in AND expression */
    SQL_filter_term_ptr clone_tail; /* last cloneable term in AND expression */
    char * field;                   /* sample field name */
    char * expr;                    /* filter expression */
    char * expr_two;                /* second expression for BETWEEN */
    SQLRelationshipKind opcode;     /* SQL opcode */
    RTIBool cloned;                 /* cloned node owns no memory */
} SQL_filter_term;


typedef struct {
    char *filterParameters;
    int parameterLength;
} SQL_filter_parameters;

extern REDADllExport
RTIBool REDAString_isSQLNumericRelationshipIntersect(
        SQL_filter_term * left, SQL_filter_term * right);

extern REDADllExport
RTIBool REDAString_hasIntersectingFilter(
        const char *s1, const char *s2, char c,
        SQL_filter_parameters *contentFilter);

extern REDADllExport
RTIBool REDAString_strToLong(
    const char *str,
    RTI_INT32 *longOut);

extern REDADllExport
RTIBool REDAString_strToUnsignedShort(
    const char * str, RTI_UINT16 *shortOut);

extern REDADllExport
RTIBool REDAString_strToUnsignedLong(
    const char *str, RTI_UINT32 *unsignedLongOut);

extern REDADllExport char * 
REDAString_strToken(char *s1, const char *delim, char **save);

extern REDADllExport char * 
REDAString_strTokenNext(const char *s1, const char *delim, char **save);


#define REDAString_nullSafe(str, strWhenNull) (str != NULL ? str : strWhenNull)


#ifdef __cplusplus
    }	/* extern "C" */
#endif

#endif /* reda_string_h */
